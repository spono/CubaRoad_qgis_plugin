# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CubaRoad_1_function
                                 A QGIS plugin
 This is an adaptation of the CubaRoad app for in qgis uses
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-27
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import numpy as np
import os,math,datetime,shutil
from osgeo import gdal,ogr,osr
from scipy import interpolate,spatial
from qgis.core import QgsMessageLog, Qgis
from qgis.PyQt.QtCore import QCoreApplication
import matplotlib.pyplot as plt
import matplotlib._color_data as mcd
global fig 
fig = False


def console_info(mess):
    mess = str(mess)
    QgsMessageLog.logMessage(mess,'CubaRoaD',Qgis.Info)


###############################################################################
### Function
###############################################################################
    

def check_field(filename,fieldname):    
    test=0
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            test=1
            break
    if test:
        featureCount = layer.GetFeatureCount()
        vals = []
        for feat in layer:
            val = feat.GetField(fieldname)
            if val is not None:
                vals.append(feat.GetField(fieldname))
        source_ds.Destroy() 
        if len(vals)!=featureCount:
            test=2
    return test


def raster_get_info(in_file_name):
    source_ds = gdal.Open(in_file_name)    
    src_proj = osr.SpatialReference(wkt=source_ds.GetProjection())
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,_,ymax,_,Csize_y = source_ds.GetGeoTransform()
    ymin = ymax+src_nrows*Csize_y
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [src_ncols,src_nrows,xmin,ymin,Csize_x,nodata]
    Extent = [xmin,xmin+src_ncols*Csize_x,ymin,ymax]
    return names,values,src_proj,Extent


#Chech all spatial entries before processing
def check_files(Dtm_file,Road_file,from_Sylvaroad):
    test = 1    
    Csize = None
    mess=QCoreApplication.translate("MainWindow","\nLES PROBLEMES SUIVANTS ONT ETE IDENTIFIES CONCERNANT LES ENTREES SPATIALES: \n")
    #Check DTM    
    try:
        _,values,_,_ = raster_get_info(Dtm_file) 
        ##test
        console_info(f"values : {values}") 
        Csize = values[4]
        if values[5]==None:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Raster MNT : Aucune valeur de NoData definie\n" )
    except:
        #test=0 !!!!!!!!!!
        mess+=QCoreApplication.translate("MainWindow"," -   Raster MNT :  Le chemin d'acces est manquant ou incorrect. Ce raster est obligatoire\n" )
            
    #Check Roadfile 
    try:    
        testfd = check_field(Road_file,"L_PLAT")
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Le champs 'L_PLAT' est manquant\n"  )
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Veuillez remplir le champs 'L_PLAT' pour toutes les entités\n" )
        testfd = check_field(Road_file,"PT_AMONT")    
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Le champs 'PT_AMONT' est manquant\n"  )
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Veuillez remplir le champs 'PT_AMONT' pour toutes les entités\n" )
        testfd = check_field(Road_file,"PT_AVAL")    
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Le champs 'PT_AVAL' est manquant\n"  )
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Veuillez remplir le champs 'PT_AVAL' pour toutes les entités\n" )        
        if from_Sylvaroad:
            testfd = check_field(Road_file,"METHOD")    
            if testfd==0: 
                test=0
                mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Le champs 'METHOD' est manquant\n")
            elif testfd==2:  
                test=0
                mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Veuillez remplir le champs 'METHOD' pour toutes les entités\n" )
        
    except:
         #test=0 !!!!!!!!!!!!
        mess+=QCoreApplication.translate("MainWindow"," -   Couche de desserte : Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire\n")
    ##Quick fix for test need to solve Csize = nonetype error 
    Csize = 5
    ##
    return test,mess,Csize


def build_xyz_tab(dtm,values):
    nrows,ncols = dtm.shape
    Csize = values[4]
    Tab_xyz = np.zeros((nrows*ncols,3),dtype=np.float32)
    x0 = values[2]+0.5*Csize
    y0 = values[3]+0.5*Csize
    idline = 0    
    for i in range(nrows):
        for j in range(ncols):
            x,y,z = x0+j*Csize,y0+i*Csize,dtm[nrows-1-i,j]
            Tab_xyz[idline]=x,y,z
            idline += 1     
    dtmtree = spatial.cKDTree(Tab_xyz[:,:2])
    return Tab_xyz,dtmtree


def get_z(coords,dtmtree,Tab_xyz):
    Dists,Inds = dtmtree.query(coords, k=4)
    if Dists[0]==0:
        return Tab_xyz[Inds[0],2]
    else:
        w = 1/Dists
        return np.sum(Tab_xyz[Inds,2]*w)/np.sum(w)


def calculate_azimut(x1,y1,x2,y2):
    """
    Calculate the azimuth between two points from their coordinates
    """
    DX = x2-x1
    DY = y2-y1
    Deuc = math.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = math.degrees(math.acos(DY/Deuc))
    Angle *=Fact
    return Angle%360


def linestring_to_seg(Road_file,Tab_xyz,dtmtree):    
    """
    Extract all vertices from line shapefile    
    """   
    # Get line info
    source_ds = ogr.Open(Road_file)
    source_layer = source_ds.GetLayer()
    source_srs = source_layer.GetSpatialRef()

    geoLocations = []
    ind = 1
   
    for feat in source_layer:
        geom = feat.GetGeometryRef()
        points = geom.GetPointCount()   
        try: 
            pt_rock = feat.GetField("P_ROCHER")
            if pt_rock is None:
                pt_rock =0
        except:
            pt_rock = 0
        try: 
            method = feat.GetField("METHOD")
            if method is None:
                method =0
        except:
            method = 0
        l_plat = feat.GetField("L_PLAT")
        s_up = feat.GetField("PT_AMONT")
        s_down = feat.GetField("PT_AVAL")  
        for p in range(points-1):
            seg = [ind] #0 seg_id
            mx,my,z = geom.GetPoint(p)        
            mz=get_z([mx,my],dtmtree,Tab_xyz)
            seg.append(mx) #1 
            seg.append(my) #2 
            seg.append(mz) #3 
            mx,my,z = geom.GetPoint(p+1)            
            mz=get_z([mx,my],dtmtree,Tab_xyz)
            seg.append(mx) #4 
            seg.append(my) #5 
            seg.append(mz) #6 
            seg.append(0) #7 azimut
            seg.append(l_plat) #8
            seg.append(s_up) #9
            seg.append(s_down) #10
            seg.append(pt_rock) #11
            seg.append(method) #12
            geoLocations.append(seg) 
            ind+=1                  
            
    geo = np.zeros((len(geoLocations),18),dtype=np.float32)        
    geo[:,0:11]=np.array(geoLocations)[:,0:-2]
    geo[:,15:-1]=np.array(geoLocations)[:,-2:]        
    geo[:,11] = geo[:,4]-geo[:,1] #delta x
    geo[:,12] = geo[:,5]-geo[:,2] #delta y
    geo[:,13] = np.sqrt(np.power(geo[:,11],2)+np.power(geo[:,12],2)) #L
    
    #calculation of azimut
    for i,s in enumerate(geo):    
        if s[13]>0:
            geo[i,7]=calculate_azimut(s[1],s[2],s[4],s[5])        
    #Recalculate z on hairpin point
    nbpt = geo.shape[0]
    idlac=1
    for i in range(nbpt-1):
        if geo[i,16]==0 and geo[i+1,16]==1: 
            z0=geo[i,3]
            d=geo[i,13]
            geo[i,17]=idlac
            j=i+1
            while geo[j,16]==1:
                d+=geo[j,13]
                geo[j,17]=idlac
                j+=1
            geo[j,17]=idlac
            idlac+=1
            d+=geo[j,13]
            z1=geo[j,6]
            slope = (z1-z0)/d
            d=geo[i,13]
            z=z0+slope*d
            geo[i,6]=z
            j=i+1
            while geo[j,16]==1:
                geo[j,3]=z                
                d+=geo[j,13]                
                z=z0+slope*d
                geo[j,6]=z
                j+=1
            geo[j,3]=z  
    tp = geo[:,13]!=0            
    geo[tp,14] = (geo[tp,6]-geo[tp,3])/geo[tp,13] #slope in the road direction
    try:
        inds = np.argwhere(geo[:,13]==0)[0,:]
        for i in inds:     
            ib = int(max(0,i-1))
            ia = int(min(i+1,nbpt-1))       
            geo[i,14]=0.5*(geo[ib,14]+geo[ia,14])
            geo[i,7]=0.5*(geo[ib,7]+geo[ia,7])   
    except:
        pass
    
    return geo,source_srs


def diff_az(az_to,az_from):   
    if az_to>az_from:
        return min((360-(az_to-az_from),(az_to-az_from)))
    else:
        return min((360-(az_from-az_to),(az_from-az_to)))


def mean_az(az_from,az_to):
    diff = diff_az(az_to,az_from)   
    if diff<90:
        diff2=180-diff
    else:
        diff2=diff
    sign=1
    if abs((az_to-diff)%360-az_from)<0.1:
        sign*=-1
    az_biss = (az_from+sign*0.5*diff2)%360
    az = (az_biss+90)%360  
    if diff_az(az_to,az) > 110:
        az-=180
    return  az%360


def cut_seg_at_step_h(seg_list,step):
    nbseg = seg_list.shape[0]
    nbline = 10*nbseg
    if step!=None and step>0:
        nbline += int(np.sum(np.ceil(seg_list[:,13]/step)))
    new_seg = np.zeros((nbline,13),dtype=np.float32)    
    seg = seg_list[0]
    new_seg[0] = [seg[1],seg[2],seg[3],seg[7],seg[8],seg[9],seg[10],seg[14],0, 1,    1,    1, seg[15]]
    #             x      y       z     az     lplat  sup    sdown   slope   lapplicable  idseg idpt  ex proche
    #             0      1       2     3      4      5      6       7       8            9     10    11 12
    idline=1
    az = seg[7]
    lplat = seg[8]
    sup = seg[9]
    sdown = seg[10]
    slope = seg[14]
    proch = seg[15]
    idpoint=2    
    for idseg,seg in enumerate(seg_list):         
        Lseg = seg[13]  
        #Check if there is hairpin on the next segment
        if idseg+1<nbseg:
            if not seg[16] and seg_list[idseg+1,16]==1:
                new_seg[idline-1,8]+=0.5*Lseg   
                continue 
        
        #Check if there was hairpin on the last segment
        if not seg[16] and seg_list[idseg-1,16]==1:
            az = seg[7]
            lplat = seg[8]
            sup = seg[9]
            sdown = seg[10]
            slope = seg[14]
            proch = seg[15]
            new_seg[idline] = seg[4],seg[5],seg[6],az,lplat,sup,sdown,slope,0.5*Lseg,idseg+1,idpoint,1,proch
            idline+=1
            idpoint+=1
            continue   
       
        #Within hairpin continue
        if seg[16]:
            continue
        
        check_bef=1              
        az = seg[7]
        if lplat != seg[8]:
            check_bef=0
        lplat = seg[8]
        if sup != seg[9]:
            check_bef=0
        sup = seg[9]
        if sdown != seg[10]:
            check_bef=0
        if proch != seg[15]:
            check_bef=0
                
        sdown = seg[10]
        slope = seg[14]
        proch = seg[15]
        dx = seg[11]
        dy= seg[12]
        x0,y0,z0 = seg[1],seg[2],seg[3]   
        
        
        if not check_bef:            
            idpoint-=1
                 
        if step==None or Lseg<=step :
            if check_bef:#slope and platform are similar
                new_seg[idline-1,8]+=0.5*Lseg 
                new_seg[idline-1,3]=az
                new_seg[idline] = seg[4],seg[5],seg[6],az,lplat,sup,sdown,slope,0.5*Lseg,idseg+1,idpoint,1,seg[15]
                idline+=1
                idpoint+=1
            else:#slope and platform are different, add one point at segment start                
                new_seg[idline-1,3]=az
                new_seg[idline] = seg[1],seg[2],seg[3],az,lplat,sup,sdown,slope,0.5*Lseg,idseg+1,idpoint,1,seg[15]
                idpoint+=1
                idline+=1   
                new_seg[idline] = seg[4],seg[5],seg[6],az,lplat,sup,sdown,slope,0.5*Lseg,idseg+1,idpoint,1,seg[15]
                idline+=1
                idpoint+=1
        else:                            
            #else the segment is cut off            
            nbcut=1
            step2 = Lseg/(nbcut+1) 
            while step2>step:
                nbcut+=1
                step2 = Lseg/(nbcut+1) 
                
            if check_bef:
                new_seg[idline-1,8]+=0.5*step2
                new_seg[idline-1,3]=az
                
            else:#direction, slope and platform are different, add one point at segment start
                new_seg[idline-1,3]=az
                new_seg[idline] = seg[1],seg[2],seg[3],az,lplat,sup,sdown,slope,0.5*step2,idseg+1,idpoint,1,seg[15]
                idpoint+=1
                idline+=1  
                                
            Lcum = 0.5*step2
            for i in range(nbcut):
                Lcum+=step2                
                nx = (i+1)*step2/Lseg*dx+x0
                ny = (i+1)*step2/Lseg*dy+y0  
                nz = (i+1)*step2*slope+z0  
                if Lcum<Lseg:
                    new_seg[idline]= nx,ny,nz,az,lplat,sup,sdown,slope,step2,idseg+1,idpoint,0,seg[15]
                else:
                    L=0.5*(Lseg-(Lcum-0.5*step2))
                    new_seg[idline]= nx,ny,nz,az,lplat,sup,sdown,slope,L+0.5*step2,idseg+1,idpoint,0,seg[15]
                idline+=1   
                idpoint+=1
            if Lcum<Lseg:
                new_seg[idline]=seg[4],seg[5],seg[6],az,lplat,sup,sdown,slope,Lseg-Lcum,idseg+1,idpoint,1,seg[15]       
            else:                
                new_seg[idline]=seg[4],seg[5],seg[6],az,lplat,sup,sdown,slope,L,idseg+1,idpoint,1,seg[15]
            idline+=1  
            idpoint+=1         
            
    new_seg=new_seg[new_seg[:,4]>0]
    
    return new_seg


def get_hairpin(seg_list):
    nblac = int(np.max(seg_list[:,17]))
    nbpt = np.sum(seg_list[:,17]>0)
    centers = np.zeros((nblac,4),dtype=np.float32) 
    #idlac x y z 
    pts = np.zeros((nbpt,15),dtype=np.float32)  
   #x y z az lplat sup sdown slope lapplicable idseg idpt type idlac posi proche
   #0 1 2 3  4     5   6     7     8           9     10   11   12    13   15
    idline = 0
    for idlac in range(1,nblac+1):    
        inds = np.argwhere(seg_list[:,17]==idlac)
        #get center coordinate
        xc,yc,zc = get_origin(seg_list,inds)
        centers[idlac-1]=idlac,xc,yc,zc
        idpoint=1
        idpt = inds[0,0]
        seg = seg_list[idpt]
        idseg=seg[0]
        pts[idline] = seg[4],seg[5],seg[6],seg[7],seg[8],seg[9],seg[10],seg[14],0.5*seg[13] ,idseg,idpoint,2, idlac, 1  ,seg[15]
        idline+=1
        idpoint+=1
        for i in inds[1:-1]:
            idpt = i[0]
            seg = seg_list[idpt]
            idseg=seg[0]
            Lseg = seg[13] 
            pts[idline-1,8] += 0.5*Lseg
            pos=2
            if i==inds[-2]:
                pos=3           
            pts[idline] = seg[4],seg[5],seg[6],seg[7],seg[8],seg[9],seg[10],seg[14],0.5*Lseg,idseg,idpoint,2, idlac, pos,seg[15]
            idline+=1
            idpoint+=1
        seg = seg_list[idpt+1]
        Lseg = seg[13] 
        pts[idline-1,8] += 0.5*Lseg
    pts = pts[pts[:,4]>0]                     
    return pts,centers


def get_pt_analyse(seg_list,step):
    pt_straight_line = cut_seg_at_step_h(seg_list,step)
    pt_lace,centers_lac = get_hairpin(seg_list)

    nbpt_s = pt_straight_line.shape[0]
    nbpt = nbpt_s+pt_lace.shape[0]
    pt_analyse = np.zeros((nbpt,16),dtype=np.float32)
    pt_analyse[0:nbpt_s,0:12]=pt_straight_line[:,0:-1]
    pt_analyse[0:nbpt_s,15]=pt_straight_line[:,-1]
    pt_analyse[nbpt_s:,0:-2]=pt_lace[:,0:-1]
    pt_analyse[nbpt_s:,15]=pt_lace[:,-1]
    tp = pt_analyse[:,12]>0
    pt_analyse[tp,14]=pt_analyse[tp,10]

    ind= np.lexsort([pt_analyse[:,10],pt_analyse[:,9]])
    pt_analyse = pt_analyse[ind]
    
    for i in range(nbpt):        
        if pt_analyse[i,13]==1:
            id_pt_bef=pt_analyse[i-1,10]
        if pt_analyse[i,12]>0:
            pt_analyse[i,10]=id_pt_bef+pt_analyse[i,14]
        if pt_analyse[i,13]==3:
            pt_analyse[i+1:,10]+=pt_analyse[i,14]
            
    #correction of azimuts
    for i in range(1,nbpt-1):
        if pt_analyse[i+1,10]==pt_analyse[i,10]:
            az_from = calculate_azimut(pt_analyse[i-1,0],pt_analyse[i-1,1],pt_analyse[i,0],pt_analyse[i,1])
            az_to = calculate_azimut(pt_analyse[i,0],pt_analyse[i,1],pt_analyse[i+2,0],pt_analyse[i+2,1])                
            pt_analyse[i,3] = mean_az(az_from,az_to)
        elif pt_analyse[i-1,10]==pt_analyse[i,10]:
            pt_analyse[i,3] = pt_analyse[i-1,3]
        else:
            az_from = calculate_azimut(pt_analyse[i-1,0],pt_analyse[i-1,1],pt_analyse[i,0],pt_analyse[i,1])
            az_to = calculate_azimut(pt_analyse[i,0],pt_analyse[i,1],pt_analyse[i+1,0],pt_analyse[i+1,1])                
            pt_analyse[i,3] = mean_az(az_from,az_to)
                  
    return pt_analyse,centers_lac
    

def get_origin(seg_list,inds):
    i = inds[2][0]
    j = inds[-2][0]
    ax,ay = seg_list[i,1],seg_list[i,2]
    bx,by = seg_list[i+1,1],seg_list[i+1,2]
    cx,cy = seg_list[i+2,1],seg_list[i+2,2]
    d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))
    ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d
    uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d
    uz = np.mean(seg_list[i:j,3])
    return (ux,uy,uz)


def save_pt_analyse(pt_analyse,centers_lac,Res_dir,source_srs):
    ###############################################
    ### Save analysis point
    ###############################################        
    Point_Shape_Path = Res_dir+"Pt_analyse_init.shp"
    #Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')      
    #Create output point shapefile
    if os.path.exists(Point_Shape_Path):driver.DeleteDataSource(Point_Shape_Path)
    target_ds = driver.CreateDataSource(Point_Shape_Path)
    layerName = os.path.splitext(os.path.split(Point_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('ID_PT', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('ID_SEG', ogr.OFTInteger)
    layer.CreateField(new_field)    
    new_field = ogr.FieldDefn('ID_LACET', ogr.OFTInteger)
    layer.CreateField(new_field) 
    new_field = ogr.FieldDefn('ELEV', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_LONG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PLAT', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AMONT', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AVAL', ogr.OFTReal)
    layer.CreateField(new_field)        
    new_field = ogr.FieldDefn('L_APP', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_TYPE', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('TYPE', ogr.OFTString)
    layer.CreateField(new_field)          
    
    for pointIndex, seg in enumerate(pt_analyse):          
        # Create point
        geometry = ogr.Geometry(ogr.wkbPoint)
        geometry.AddPoint(float(seg[0]), float(seg[1]))
        # Create feature
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(pointIndex)
        feature.SetField('ELEV',seg[2])   
        feature.SetField('AZI',seg[3])  
        feature.SetField('L_PLAT',seg[4])   
        feature.SetField('PT_AMONT',seg[5]) 
        feature.SetField('PT_AVAL',seg[6]) 
        feature.SetField('PT_LONG',seg[7])
        feature.SetField('ID_SEG',seg[9]) 
        feature.SetField('ID_PT',seg[10])
        feature.SetField('ID_LACET',seg[12])
        feature.SetField('L_APP',seg[8])            
        feature.SetField('PT_TYPE',int(seg[11])) 
        if seg[11]==1:
            feature.SetField('TYPE','Point de niveau')
        elif seg[11]==0:
            feature.SetField('TYPE','Point analyse sup')
        else:
            if seg[13]==1:
                feature.SetField('TYPE', "Lacet entree")
            elif seg[13]==2:
                feature.SetField('TYPE',"Lacet rayon")
            else:
                feature.SetField('TYPE',"Lacet sortie")
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        geometry.Destroy()
        feature.Destroy()
    
    ##############################
    # Center point of lace turn
    ##############################
    Point_Shape_Path = Res_dir+"Lacets_centres.shp"
    #Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')      
    #Create output point shapefile
    if os.path.exists(Point_Shape_Path):driver.DeleteDataSource(Point_Shape_Path)
    target_ds = driver.CreateDataSource(Point_Shape_Path)
    layerName = os.path.splitext(os.path.split(Point_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()        
    new_field = ogr.FieldDefn('ID_LACET', ogr.OFTInteger)
    layer.CreateField(new_field)        
    new_field = ogr.FieldDefn('ELEV', ogr.OFTReal)
    layer.CreateField(new_field)        
    for pointIndex, center in enumerate(centers_lac):          
        # Create point
        geometry = ogr.Geometry(ogr.wkbPoint)
        geometry.AddPoint(float(center[1]), float(center[2]))
        # Create feature
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(pointIndex)
        feature.SetField('ELEV',center[3])               
        feature.SetField('ID_LACET',center[0])                    
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        geometry.Destroy()
        feature.Destroy()
    # Cleanup
    target_ds.Destroy()


def build_trans(pt_analyse,centers_lac,Csize,Res_dir,save_shp,source_srs): 
    s_radius = max(15,3*Csize)
    Tab = np.zeros((pt_analyse.shape[0],18),dtype=np.float32)
    #x y z xc/x1 yc/y1 zc x2 y2 azi lpla pamont paval slope Lapp idseg idpoint pt_type idlac
    #0 1 2 3     4     5  6  7  8   9    10     11    12    13   14    15      16      17    
    
    if save_shp:    
        driver = ogr.GetDriverByName('ESRI Shapefile')      
        #Create output point shapefile
        trans_shp=Res_dir+"Transect.shp"
        if os.path.exists(trans_shp):driver.DeleteDataSource(trans_shp)
        target_ds = driver.CreateDataSource(trans_shp)
        layerName = os.path.splitext(os.path.split(trans_shp)[1])[0]
        layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbLineString)
        layerDefinition = layer.GetLayerDefn()    
        new_field = ogr.FieldDefn('ID_PT', ogr.OFTInteger)
        layer.CreateField(new_field)
        new_field = ogr.FieldDefn('TYPE', ogr.OFTInteger)
        layer.CreateField(new_field)
            
    #Build Trans for straight line  
    for i,pt in enumerate(pt_analyse):        
        if pt[11]<2:
            az = conv_az_to_polar(pt[3])
            Tab[i,0:3] = pt[0:3]        
            pt1_x = s_radius*math.cos(math.radians((az-90)%360))+pt[0]
            pt1_y = s_radius*math.sin(math.radians((az-90)%360))+pt[1]
            pt2_x = s_radius*math.cos(math.radians((az+90)%360))+pt[0]
            pt2_y = s_radius*math.sin(math.radians((az+90)%360))+pt[1]
            Tab[i,3:5]=pt1_x,pt1_y
            Tab[i,6:8]=pt2_x,pt2_y
            Tab[i,8:]=pt[3:13]
            if save_shp:
                line = ogr.Geometry(ogr.wkbLineString)
                line.AddPoint(pt2_x,pt2_y)
                line.AddPoint(pt1_x,pt1_y)            
                feature = ogr.Feature(layerDefinition)
                feature.SetGeometry(line)
                feature.SetField('ID_PT',int(pt[10]))
                feature.SetField('TYPE',int(pt[11]))    
                feature.SetFID(i)
                layer.CreateFeature(feature)
                line.Destroy()
                feature.Destroy()    
    
    #Build Trans for lace turn
    nblac = int(np.max(pt_analyse[:,12]))      
    for idlac in range(1,nblac+1):    
        inds = np.argwhere(pt_analyse[:,12]==idlac) 
        nbpt = inds.shape[0]
        idmin = 0
        idmax = nbpt  
        i1 = inds[0][0]
        i2 = inds[-1][0]
        i3 = inds[1][0]
        i4 = inds[-2][0]
        #coordinate of circle of radius
        xc,yc,zc = centers_lac[idlac-1,1:]
        #identify if lace if very wide
        radius = round(Distplan(yc,xc,pt_analyse[i3+1,1],pt_analyse[i3+1,0]),0)
        Dext = round(Distplan(pt_analyse[i1,1],pt_analyse[i1,0],pt_analyse[i2,1],pt_analyse[i2,0]),0)
        if Dext>2*radius: 
            idmin += 1
            idmax -= 1  
            pt = pt_analyse[i1]
            az = conv_az_to_polar(pt[3])
            for i in [i1,i2]:
                pt=pt_analyse[i]
                az_from = calculate_azimut(pt_analyse[i-1,0],pt_analyse[i-1,1],pt[0],pt[1])
                az_to = calculate_azimut(pt[0],pt[1],pt_analyse[i+1,0],pt_analyse[i+1,1])                
                az = conv_az_to_polar(mean_az(az_from,az_to))
                Tab[i,0:3] = pt[0:3]        
                pt1_x = s_radius*math.cos(math.radians((az-90)%360))+pt[0]
                pt1_y = s_radius*math.sin(math.radians((az-90)%360))+pt[1]
                pt2_x = s_radius*math.cos(math.radians((az+90)%360))+pt[0]
                pt2_y = s_radius*math.sin(math.radians((az+90)%360))+pt[1]
                Tab[i,3:5]=pt1_x,pt1_y
                Tab[i,6:8]=pt2_x,pt2_y
                Tab[i,8:]=pt[3:13]
                Tab[i,16]=3
                if save_shp:
                    line = ogr.Geometry(ogr.wkbLineString)
                    line.AddPoint(pt2_x,pt2_y)
                    line.AddPoint(pt1_x,pt1_y)            
                    feature = ogr.Feature(layerDefinition)
                    feature.SetGeometry(line)
                    feature.SetField('ID_PT',int(pt[10]))
                    feature.SetField('TYPE',3)    
                    feature.SetFID(i)
                    layer.CreateFeature(feature)
                    line.Destroy()
                    feature.Destroy()  
            Dext2 = round(Distplan(pt_analyse[i3,1],pt_analyse[i3,0],pt_analyse[i4,1],pt_analyse[i4,0]),0)
            if Dext2>=radius:
                idmin += 1
                idmax -= 1 
                for i in [i3,i4]:
                    pt=pt_analyse[i]
                    az_from = calculate_azimut(pt_analyse[i-1,0],pt_analyse[i-1,1],pt[0],pt[1])
                    az_to = calculate_azimut(pt[0],pt[1],pt_analyse[i+1,0],pt_analyse[i+1,1])                
                    az = conv_az_to_polar(mean_az(az_from,az_to))
                    Tab[i,0:3] = pt[0:3]        
                    pt1_x = s_radius*math.cos(math.radians((az-90)%360))+pt[0]
                    pt1_y = s_radius*math.sin(math.radians((az-90)%360))+pt[1]
                    pt2_x = s_radius*math.cos(math.radians((az+90)%360))+pt[0]
                    pt2_y = s_radius*math.sin(math.radians((az+90)%360))+pt[1]
                    Tab[i,3:5]=pt1_x,pt1_y
                    Tab[i,6:8]=pt2_x,pt2_y
                    Tab[i,8:]=pt[3:13]
                    Tab[i,16]=3
                    if save_shp:
                        line = ogr.Geometry(ogr.wkbLineString)
                        line.AddPoint(pt2_x,pt2_y)
                        line.AddPoint(pt1_x,pt1_y)            
                        feature = ogr.Feature(layerDefinition)
                        feature.SetGeometry(line)
                        feature.SetField('ID_PT',int(pt[10]))
                        feature.SetField('TYPE',3)    
                        feature.SetFID(i)
                        layer.CreateFeature(feature)
                        line.Destroy()
                        feature.Destroy()  
                 
        #coordinate of center between input and output
        xc2 = 0.5*(pt_analyse[i1,0]+pt_analyse[i2,0])
        yc2 = 0.5*(pt_analyse[i1,1]+pt_analyse[i2,1])
        zc2 = 0.5*(pt_analyse[i1,2]+pt_analyse[i2,2])  
        xc3 = 0.5*(pt_analyse[i3,0]+pt_analyse[i4,0])
        yc3 = 0.5*(pt_analyse[i3,1]+pt_analyse[i4,1])
        zc3 = 0.5*(pt_analyse[i3,2]+pt_analyse[i4,2])         
        for i in inds[idmin:idmax,0]:
            x,y,z = pt_analyse[i,:3]
            Tab[i,0:3] = x,y,z
            if i==i1 or i==i2:
                Tab[i,3:6] = xc2,yc2,zc2
                az = calculate_azimut(x, y, xc2, yc2)
            elif i==i3 or i==i4:
                Tab[i,3:6] = xc3,yc3,zc3
                az = calculate_azimut(x, y, xc3, yc3)                
            else:
                Tab[i,3:6] = xc,yc,zc
                az = calculate_azimut(x, y, xc, yc)
            pol = conv_az_to_polar(az)
            pt1_x = s_radius*math.cos(math.radians((pol-180)%360))+x
            pt1_y = s_radius*math.sin(math.radians((pol-180)%360))+y            
            Tab[i,6:8]=pt1_x,pt1_y
            Tab[i,8:]=pt_analyse[i,3:13]            
            if save_shp:
                line = ogr.Geometry(ogr.wkbLineString)
                if i==i1 or i==i2:
                    line.AddPoint(xc2,yc2)
                elif i==i3 or i==i4:                    
                    line.AddPoint(xc3,yc3)
                else:
                    line.AddPoint(xc,yc)
                line.AddPoint(pt1_x,pt1_y)            
                feature = ogr.Feature(layerDefinition)
                feature.SetGeometry(line)
                feature.SetField('ID_PT',int(pt_analyse[i,10]))
                feature.SetField('TYPE',int(pt_analyse[i,11])) 
                feature.SetFID(i)
                layer.CreateFeature(feature)
                line.Destroy()
                feature.Destroy()
    if save_shp:
        target_ds.Destroy()    
    
    return Tab


def conv_az_to_polar(az):
    return (360-(az-90))%360


def load_float_raster(raster_file):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)
    gt = dataset.GetGeoTransform()
    cols = dataset.RasterXSize
    rows = dataset.RasterYSize    
    geotransform = dataset.GetGeoTransform()
    xmin = geotransform[0]
    xmax = xmin + geotransform[1]*cols
    ymax = geotransform[3]
    ymin = geotransform[3] + geotransform[5]*rows
    Extent = [xmin,xmax,ymin,ymax]
    Csize = abs(geotransform[1])
    proj = dataset.GetProjection()
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [round(cols,2), round(rows,2), round(xmin,2), round(ymin,2), round(Csize,2),round(nodatavalue,2)]
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array),Extent,Csize,proj,names,values,gt


def get_profile_intersection2(fz,alt,idC,step2,step3,z_tolerance):
    diffz = fz[idC-step3:idC+step3+1]-alt
    diffs = step2*(np.arange(idC-step3,idC+step3+1)-idC)
    diffz[np.abs(diffz)>z_tolerance]=1000
    diff = np.sqrt(diffz*diffz+diffs*diffs)
    if np.min(diff)>=1000:       
        return np.argmin(diff)+idC-step3,False
    else:
        return np.argmin(diff)+idC-step3,True
    

def get_profile_intersection2bis(fz2,alt,idC,step2,z_tolerance):
    diffz = fz2-alt
    diffs = step2*(np.arange(0,fz2.shape[0])-idC)
    diffz[np.abs(diffz)>z_tolerance]=1000
    diff = np.sqrt(diffz*diffz+diffs*diffs)
    if np.min(diff)>=1000:       
        return np.argmin(diff),False
    else:
        return np.argmin(diff),True
    

def get_profile_intersection3(fz,alt,idC,step3):
    diffz = np.abs(fz[idC-step3:idC+step3+1]-alt)   
    return np.argmin(diffz)+idC-step3


def get_upper_cross_slope(slope_left,slope_right, min_exca_slope = 0.25, max_exca_slope = 0.60):
    if max(slope_left,slope_right)<0:
        cross_slope_upper = None
        way = "top"
        ripage = 0
    elif min(slope_left,slope_right)>0:
        cross_slope_upper = max(slope_left,slope_right)
        way = "hole"
        ripage = 0
    else:
        if slope_left>slope_right:
            if abs(slope_right)<max_exca_slope:
                cross_slope_upper = abs(slope_left)
            else:
                cross_slope_upper = abs(slope_right)
            way = "left"
        else:
            if abs(slope_left)<max_exca_slope:
                cross_slope_upper = abs(slope_right)
            else:
                cross_slope_upper = abs(slope_left)
            way = "right"        
        if cross_slope_upper >= max_exca_slope:
            ripage = 1
        else:
            ripage = (cross_slope_upper - min_exca_slope) / (max_exca_slope - min_exca_slope)      
    return way,ripage


def get_slope_id(s_up):
    #slope of uphill bank
    sl_list=np.array([0.67,1.0,1.5,4.0])
    sid=0     
    for i,s in enumerate(sl_list) :
        sid=i
        if s>=s_up:
            break
    return sid


def get_coord_pt_niv(tr,Dnivel):
    x1,y1 = tr[3],tr[4]   
    x2,y2 = tr[6],tr[7]
    xcp,ycp = x1-x2,y1-y2     
    R = math.sqrt(xcp**2+ycp**2)
    x = xcp/R*Dnivel+x2
    y = ycp/R*Dnivel+y2    
    return  x,y    


def get_coord_pt_niv2(tr,Dnivel):
    x1,y1 = tr[6],tr[7]   
    x2,y2 = tr[3],tr[4]
    xcp,ycp = x1-x2,y1-y2     
    R = math.sqrt(xcp**2+ycp**2)
    x = xcp/R*Dnivel+x2
    y = ycp/R*Dnivel+y2    
    return  x,y    


def build_prof(x1,y1,x2,y2,Tab_xyz,dtmtree):
    z1 = get_z([x1,y1], dtmtree,Tab_xyz)  
    z2 = get_z([x2,y2], dtmtree,Tab_xyz)  
    xcp,ycp = x1-x2,y1-y2 
    R = math.sqrt(xcp**2+ycp**2)
    cosa = xcp/R 
    sina = ycp/R
    Dist = [0]
    Elev = [z2]    
    # Cleanup
    for d in range(1,int(R),1):
        x = cosa*d+x2
        y = sina*d+y2  
        z = get_z([x,y], dtmtree,Tab_xyz) 
        Dist.append(d)
        Elev.append(z)
    Dist.append(R)
    Elev.append(z1)    
    return  np.array(Dist),np.array(Elev),R


def get_profil(tr,i,Pt_list,Tab_xyz,dtmtree,min_exca_slope = 0.35, max_exca_slope = 0.60,xy_tolerance=2,z_tolerance=0.05,save_fig=False,Res_dir=None,show_fig=True):
    sl_list=np.array([0.67,1.0,1.5,4.0])
    #get segment param
    xc,yc,zplat = tr[0],tr[1], tr[2]
    x1,y1 = tr[3],tr[4]
    x2,y2 = tr[6],tr[7]
    road_width = tr[9]
    s_up = tr[10]/100.
    s_down = tr[11]/100.  
    slope,Ltron,idseg,idtron = tr[12],tr[13],int(tr[14]),int(tr[15])
    
    #build profile   
    Dhor,z,distance=build_prof(x1,y1,x2,y2,Tab_xyz,dtmtree)    
    fz = interpolate.interp1d(Dhor, z, kind='slinear')    
    step2 = 0.01
    Dlist  = np.arange(0,distance,step2)
    fz = fz(Dlist)                      
    Dc = round(np.sqrt((xc-x2)*(xc-x2)+(yc-y2)*(yc-y2)),2)
    if xy_tolerance==None:
        xy_tol = 0.5*road_width
    else:
        xy_tol =xy_tolerance
        
    step3 = int(xy_tol/step2)
    step4 = int((xy_tol+0.5*road_width)/step2)
    idC = int(Dc/step2)
    
    #get the nivel point in the radiuas of road_width from theoretical road axis
    idD,test = get_profile_intersection2(fz,zplat,idC,step2,step3,z_tolerance)   
        
    test2=0    
    if not test:
        idD,test2 = get_profile_intersection2(fz,zplat,idC,step2,step4,z_tolerance)
        if not test2: # plateform below ground
            idD=get_profile_intersection3(fz,zplat,idC,step3)                      
        else:
            test=True
            
    Dnivel = Dlist[idD]
    Dl = max(Dnivel-6,0)
    zl = fz[int(Dl/step2)]
    Dr = min(Dnivel+6,distance)
    zr = fz[int(Dr/step2)]
    #get excavated width
    slope_left = (zl-zplat)/(Dnivel-Dl)
    slope_right = (zr-zplat)/(Dr-Dnivel)
    way,ripage = get_upper_cross_slope(slope_left,slope_right,
                                        min_exca_slope, max_exca_slope)
    
    diffzidD = 0
    config=4
    if not test:
        if fz[idD]-zplat>0: # plateform 100% below ground
            diffzidD = 1  
            ripage = 0   
            config=3                     
        else: # plateform 100% above ground
            way = 'top'
            diffzidD = -1  
            ripage = 0
            config=5  
    else:
        if abs(idD-idC)*step2<0.05:
            config=1
        else:
            config=2
            
    assise_deb = round(road_width / 2.0 * (1 + ripage**2),2)
    assise_remb = round(road_width - assise_deb,2)  
    
    if test2 and fz[idD]-zplat<0:
        config=4
        diffzidD = -1  
        if idD>idC:
            idborder = idC+step3
        else:
            idborder = idC-step3        
            
        assise_deb = round(road_width-abs(idborder-idD)*step2,2)
        assise_remb = round(road_width - assise_deb,2)  
    
    if test2 and fz[idD]-zplat>0:
        config=3
    
    # calcul de l'assise en deblais
    
    assiet_deb = 0 
    assiet_remb = 0
    idD0,idD1,idD2,idD3=idD,idD,idD,idD  
    zroad = np.copy(fz)
    test=1
    
    sup_id = get_slope_id(s_up)
    
    if way=='left':           
        # calcul altitude terrain apres         
        idD2 =  int((Dnivel-assise_deb)/step2)        
        zroad[idD2:idD] = zplat
        Dfrom = Dlist-Dlist[idD2]
        zroad[:idD2] = zplat-s_up*Dfrom[:idD2]
        idD3,test2 = get_profile_intersection2bis(fz[:idD2],zroad[:idD2],idD2,step2,z_tolerance)        
        while test2==0:
            sup_id+=1
            zroad[:idD2] = zplat-sl_list[sup_id]*Dfrom[:idD2]
            idD3,test2 = get_profile_intersection2bis(fz[:idD2],zroad[:idD2],idD2,step2,z_tolerance)  
            if sup_id==sl_list.shape[0]-1:
                if zroad[0]>fz[0] and not test2:
                    zroad[:idD2] = zplat+s_down*Dfrom[:idD2]
                    idD3,test2 = get_profile_intersection2bis(fz[:idD2],zroad[:idD2],idD2,step2,z_tolerance) 
                break
        
        if (diffzidD==0 and assise_remb>0) or diffzidD<0:            
            idD1 = int((Dnivel+assise_remb)/step2)
            zroad[idD:idD1+1] = zplat
            Dfrom = Dlist-Dlist[idD1]
            zroad[idD1:] = zplat-Dfrom[idD1:]*s_down
            idD0,test2 = get_profile_intersection2bis(fz[idD1:],zroad[idD1:],0,step2,z_tolerance)
            idD0+=idD1
            if not test2 and s_down<1:
                zroad[idD1:] = zplat-Dfrom[idD1:]
                idD0,test2 = get_profile_intersection2bis(fz[idD1:],zroad[idD1:],0,step2,z_tolerance)
                idD0+=idD1
            if not test2:
                zroad[idD1:] = zplat+Dfrom[idD1:]*s_up
                idD0,test2 = get_profile_intersection2bis(fz[idD1:],zroad[idD1:],0,step2,z_tolerance)
                idD0+=idD1
                        
        elif diffzidD>0:
            idD1=int((Dnivel+assise_remb)/step2)  
            zroad[idD:idD1+1] = zplat
            idcross,test2 = get_profile_intersection2bis(fz[idD1:],zplat,0,step2,z_tolerance)
            if idcross*step2<max(0.5*road_width,2) and test2:
                #on continue la plateforme  
                idD0=idcross+idD1
                zroad[idD1:idD0+1]=zplat
                idD1=idD0
            else:
                #on applique un talus amont               
                Dfrom = Dlist-Dlist[idD1]
                zroad[idD1:] = zplat+s_up*Dfrom[idD1:]
                idD0,test2 = get_profile_intersection2bis(fz[idD1:],zroad[idD1:],0,step2,z_tolerance)
                idD0+=idD1
        zroad[:idD3]=fz[:idD3]
        zroad[idD0:]=fz[idD0:]
        
        
    if way=='right': 
        # calcul altitude terrain apres 
        idD2 = int((Dnivel+assise_deb)/step2) 
        zroad[idD:idD2+1] = zplat
        Dfrom = Dlist-Dlist[idD2]
        zroad[idD2:] = zplat+s_up*Dfrom[idD2:]
        idD3,test2 = get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance)
        idD3+=idD2
        while test2==0:
            sup_id+=1
            zroad[idD2:] = zplat+sl_list[sup_id]*Dfrom[idD2:]
            idD3,test2 = get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance)
            idD3+=idD2    
            if sup_id==sl_list.shape[0]-1:
                if zroad[-1]>fz[-1] and not test2:
                    zroad[idD2:] = zplat-s_down*Dfrom[idD2:]
                    idD3,test2 = get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance) 
                    idD3+=idD2    
                break
        
        if (diffzidD==0 and assise_remb>0) or diffzidD<0: 
            if assise_remb>0:
                idD1 = int((Dnivel-assise_remb)/step2)
                zroad[idD1:idD] = zplat
                Dfrom = Dlist-Dlist[idD1]
                zroad[:idD1] = zplat+Dfrom[:idD1]*s_down
                idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
                if not test2 and s_down<1:
                    zroad[idD1:] = zplat+Dfrom[idD1:]
                    idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
                if not test2:
                    zroad[:idD1] = zplat-Dfrom[:idD1]*s_up
                    idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
                
        elif diffzidD>0:
            idD1=int((Dnivel-assise_remb)/step2) 
            zroad[idD1:idD] = zplat
            idcross,test2 = get_profile_intersection2bis(fz[:idD1],zplat,idD1,step2,z_tolerance)
            if (idD1-idcross)*step2<max(0.5*road_width,2) and test2:
                #on continue la plateforme  
                idD0=idcross
                zroad[idD0:idD1]=zplat
                idD1=idD0
            else:
                #on applique un talus amont               
                Dfrom = Dlist-Dlist[idD1]
                zroad[:idD1] = zplat-s_up*Dfrom[:idD1]
                idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance) 
        
        zroad[:idD0]=fz[:idD0]
        zroad[idD3+1:]=fz[idD3+1:]                   

    if way=='top':        
        idD2 = int((Dnivel+assise_deb)/step2) 
        zroad[idD:idD2] = zplat
        Dfrom = Dlist-Dlist[idD2]
        zroad[idD2:] = zplat+s_down*Dfrom[idD2:]
        idD3,test2 = get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance)
        idD3+=idD2
        if not test2 and s_down<1:
            zroad[idD2:] = zplat+Dfrom[idD2:]
            idD3,test2 = get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance)
            idD3+=idD2
        if not test2:
            zroad[idD2:] = zplat-s_down*Dfrom[idD2:]
            idD3,test2= get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance)
            idD3+=idD2
            if not test2 and s_down<1:
                zroad[idD2:] = zplat-Dfrom[idD2:]
                idD3,test2 = get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance)
                idD3+=idD2
        idD1 = int((Dnivel-assise_remb)/step2)
        zroad[idD1:idD] = zplat
        Dfrom = Dlist-Dlist[idD1]
        zroad[:idD1] = zplat+Dfrom[:idD1]*s_down
        idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
        if not test2 and s_down<1:
            zroad[:idD1] = zplat+Dfrom[:idD1]
            idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
        if not test2:
              zroad[:idD1] = zplat-Dfrom[:idD1]*s_down
              idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
              if not test2 and s_down<1:
                  zroad[:idD1] = zplat-Dfrom[:idD1]
                  idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
        zroad[:idD0]=fz[:idD0]
        zroad[idD3+1:]=fz[idD3+1:]   
        
    if way=='hole':         
        idD2 = int((Dnivel+assise_deb)/step2) 
        zroad[idD:idD2] = zplat
        Dfrom = Dlist-Dlist[idD2]
        zroad[idD2:] = zplat-s_up*Dfrom[idD2:]
        idD3,test2 = get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance)
        idD3+=idD2
        if not test2:
            zroad[idD2:] = zplat+s_up*Dfrom[idD2:]
            idD3,test2= get_profile_intersection2bis(fz[idD2+1:],zroad[idD2+1:],0,step2,z_tolerance)
            idD3+=idD2
        idD1 = int((Dnivel-assise_remb)/step2)
        zroad[idD1:idD] = zplat
        Dfrom = Dlist-Dlist[idD1]
        zroad[:idD1] = zplat-Dfrom[:idD1]*s_up
        idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
        if not test2:
              zroad[:idD1] = zplat+Dfrom[:idD1]*s_up
              idD0,test2 = get_profile_intersection2bis(fz[:idD1],zroad[:idD1],idD1,step2,z_tolerance)
        zroad[:idD0]=fz[:idD0]
        zroad[idD3+1:]=fz[idD3+1:]   
                       
    #section en deblais
    tp = (fz-zroad)>0
    s_deb = np.sum(fz[tp]-zroad[tp])*step2
    # zroad2 = np.ones_like(zroad[idD1:idD2+1])*min(fz[idD],zplat) 
    if np.sum(tp)>0:
        assiet_deb = step2*np.sum(tp)
        if idD1<idD2:
            assise_deb = np.sum((fz[idD1:idD2+1]-min(fz[idD],zplat))>=0)*step2
        else:
            assise_deb = np.sum((fz[idD2:idD1+1]-min(fz[idD],zplat))>=0)*step2
    else:
        assiet_deb=0
        assise_deb=0
    
    #section en remblais
    tp = (fz-zroad)<0    
    s_remb = np.sum(zroad[tp]-fz[tp])*step2
    if np.sum(tp)>0:
        assiet_remb  = step2*np.sum(tp)  
        if idD1<idD2:
            assise_remb = np.sum((fz[idD1:idD2+1]-min(fz[idD],zplat))<0)*step2
        else:
            assise_remb = np.sum((fz[idD2:idD1+1]-min(fz[idD],zplat))<0)*step2
        if assise_deb==road_width and assise_remb==0.01:
            assise_remb=0
    else:
        assiet_remb=0
        assise_remb=0
        if way=='hole':
            config=6
        
    #emprise          
    emprise = round((abs(idD0-idD3)+1)*step2,2)
    
    #####Recupere les points de rupture
    inds = np.argwhere(fz!=zroad)   
    Pt_list[i,18]=1
    Pt_list[i,19]=idtron
    g1 = inds[0,0]
    if idD<g1:
        g1=idD
    d1 = inds[-1,0]
    if idD>d1:
        d1=idD
    inds = np.argwhere(zroad==zplat)
    g2 = inds[0,0]
    if g2<g1:
        g2=g1    
    d2 = inds[-1,0]
    if d2>d1:
        d2=d1     
    center = int(0.5*(g2+d2))
    nivel = idD   
    Pt_list[i,0:2] = get_coord_pt_niv(tr,Dlist[g1])    
    Pt_list[i,2:4] = get_coord_pt_niv(tr,Dlist[g2])    
    if tr[16]==1:
        Pt_list[i,4:7] = xc,yc,zplat
        Pt_list[i,15]=1    
    else:    
        if abs(fz[nivel]-zroad[nivel])<z_tolerance:    
            Pt_list[i,4:6] = get_coord_pt_niv(tr,Dlist[nivel])
            Pt_list[i,6]=zplat
            if nivel< g2 :
                Pt_list[i,15]=2
            elif nivel> d2 :
                Pt_list[i,15]=3
            else:
                Pt_list[i,15]=1            
        else:
            #check if there is level point within extent
            nivel,test2 = get_profile_intersection2bis(fz[g1+1:d1],zroad[g1+1:d1],center-g1-1,step2,z_tolerance)
            if test2:
                Pt_list[i,4:6]=get_coord_pt_niv2(tr,Dlist[nivel])
                Pt_list[i,6]=round(fz[nivel],2)
                if nivel< g2 :
                    Pt_list[i,15]=2
                elif nivel> d2 :
                    Pt_list[i,15]=3
                else:
                    Pt_list[i,15]=1 
            
    if Pt_list[i,15]>0:
        sumdif = np.sum(zroad[g1:nivel+1]-fz[g1:nivel+1])
        if abs(sumdif)<=z_tolerance:
            Pt_list[i,16] = 0
        else:            
            Pt_list[i,16] = sumdif
        sumdif = np.sum(zroad[nivel:d1+1]-fz[nivel:d1+1])
        if abs(sumdif)<=z_tolerance:
            Pt_list[i,17] = 0
        else:            
            Pt_list[i,17] = sumdif
    else:
        sumdif = np.sum(zroad[g1:d1+1]-fz[g1:d1+1])
        Pt_list[i,16] =  sumdif
        Pt_list[i,17] =  sumdif
    Pt_list[i,7:9] = get_coord_pt_niv(tr,Dlist[center])
    Pt_list[i,9]=zplat
    Pt_list[i,10]=round(zplat-fz[center],2)
    Pt_list[i,11:13] = get_coord_pt_niv(tr,Dlist[d2])    
    Pt_list[i,13:15] = get_coord_pt_niv(tr,Dlist[d1])
    
        
    Res = np.zeros((23,))
    #ID_PT ID_SEG L_TRON PT_LONG PT_G PT_D L_ASSIS ASSIS_DEB SEC_DEB V_DEB
    #0     1      2      3       4    5    6       7         8       9
    #ASSIS_REMB S_REMB V_REMB ASSIET_DEB ASSIET_REMB EMPRISE PT_REEL CONFIG
    #10         11     12     13         14          15      16      17
    #TAL_AMONT TAL_AVAL MODIF_AMONT PIQ_CONTROL_AMONT PIQ_CONTROL_AVAL
    #18        19       20          21                22
    
    Res[0:6]=idtron,idseg,Ltron,round(slope*100,1),round(slope_left*100,1),round(slope_right*100,1)
    if np.sum(zroad==zplat)*step2>road_width+0.01:
        Res[6]=round(np.sum(zroad==zplat)*step2,2)
    else:
        Res[6]=road_width
    Res[7:10]=round(assise_deb,2),round(s_deb,5),0
    Res[10:13]=round(assise_remb,2),round(s_remb,5),0
    Res[13:18]=round(assiet_deb,2),round(assiet_remb,2),emprise,tr[16],config
    Res[18]=sl_list[sup_id]*100
    if sl_list[sup_id]*100!=s_up*100:
        Res[20]=1
    Res[19]=s_down*100
    
    
    #Piquet control amont
    idbt = idD3
    if idD0<idD3 and fz[idD0]<fz[idD3]:
        way=1
        
    else:
        way=-1
        if fz[idD0]>=fz[idD3]:
            idbt = idD0
    
    itera=0
    lpiq=0
    while itera < 1/step2 and lpiq<1:
        itera+=1
        idcon = idbt+way*itera
        if idcon >= Dlist.shape[0] or idcon<0:
            idcon = idbt+way*(itera-1)
            break
        lpiq=math.sqrt((Dlist[idcon]-Dlist[idbt])**2+(fz[idbt]-fz[idcon])**2)
        
    idcontrol_up=idcon   
    
    #Piquet control aval
    if idbt==idD3:
        idbt = idD0
    else:
        idbt = idD3
        
    way*=-1
    itera=0
    lpiq=0
    while itera < 1/step2 and lpiq<1:
        itera+=1
        idcon = idbt+way*itera
        if idcon >= Dlist.shape[0] or idcon<0:
            idcon = idbt+way*(itera-1)
            break
        lpiq=math.sqrt((Dlist[idcon]-Dlist[idbt])**2+(fz[idbt]-fz[idcon])**2)
    
    idcontrol_dw=idcon          
    
    Res[21]=round(math.sqrt((Dnivel-Dlist[idcontrol_up])**2+(fz[idcontrol_up]-zplat)**2),2)
    Res[22]=round(math.sqrt((Dnivel-Dlist[idcontrol_dw])**2+(fz[idcontrol_dw]-zplat)**2),2) 
    
    ptrav = abs(fz[idcontrol_up]-fz[idcontrol_dw])/abs(step2*(idcontrol_up-idcontrol_dw))   
    
    #plot   
    if show_fig or save_fig:     
        
        pente_trav = QCoreApplication.translate('Pente en travers: ')+str(int(ptrav*100+0.5))+"%"
        tal_amont = QCoreApplication.translate('Talus amont: ')+str(int(sl_list[sup_id]*100))+"%"
        tal_aval = QCoreApplication.translate('Talus aval: ')+str(int(s_down*100))+"%"
       
        fig_title = "Point "+str(idtron)+" - Config "+str(config)
        addtxt=""
        if Pt_list[i-1,19]==idtron:
            addtxt="_bis"                    
        fig_name = Res_dir+"Profils/"+"Pt"+str(idtron)+str(addtxt)+"_Expeditif_Cf"+str(config)+".png"
        
        idmin = int(max(min(d1,g1,idcontrol_up,idcontrol_dw,idC-step3)-1.5/step2,0))
        idmax = int(min(max(idcontrol_up,idcontrol_dw,d1,g1,idC+step3)+1.5/step2,Dlist.shape[0]-1))        
        min_elev=int(min(np.min(fz[idmin:idmax]),zplat)-1.5)
        max_elev=int(max(np.max(fz[idmin:idmax]),zplat)+2.5)
        
        base_reg=min_elev
        plt.ioff()
        fig, ax = plt.subplots(1, 1, figsize=(12,8)) 
        fig.suptitle(fig_title)        
        Dlist2 = Dlist-Dlist[idC]
        
        xmin = Dlist2[idmin]
        xmax = Dlist2[idmax]
                
        miD,maD = np.min(Dlist2),np.max(Dlist2)
        #write slopes
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=pente_trav)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=tal_amont)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=tal_aval)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        
        #terrain profile
        ax.plot(Dlist2,fz,color=mcd.XKCD_COLORS["xkcd:brown"],label=None)    
        ax.fill_between(Dlist2,fz,base_reg,color=mcd.XKCD_COLORS["xkcd:brown"],alpha=0.1,label=None)
        #theoretical center axis and elevation of road
        ax.plot([miD,maD],[zplat,zplat],':k',linewidth=2.,label=None)
        ax.plot([0,0],[min_elev,max_elev],':k',linewidth=2,label="Axe/alt. théo plateforme")
        #level point
        if  Pt_list[i,15]==1 :
            ax.plot([Dlist2[nivel],Dlist2[nivel]],[min_elev,max_elev],'--b',label="Axe de niveau")
        ax.fill_between([0-xy_tol,0-xy_tol,0+xy_tol,0+xy_tol],
                          [min_elev,max_elev,max_elev,min_elev],base_reg,
                          color=mcd.XKCD_COLORS["xkcd:salmon"],alpha=0.1,label="Zone tampon")
        
        #draw plateforme
        ax.plot(Dlist2,zroad,c='#CC79A7',linewidth=2,label="Profil après déblai/remblai")
        #draw plateforme
        ax.plot(Dlist2[g2+8:d2-7],zroad[g2+8:d2-7],c='#D55E00',linewidth=7,label="Plateforme")
        #Piquet control amont
        ax.plot([Dlist2[idcontrol_up],Dlist2[idcontrol_up]],
                [fz[idcontrol_up],fz[idcontrol_up]+1],'-g',linewidth=3,label="Piquets contrôles")
        #Piquet control amont
        ax.plot([Dlist2[idcontrol_dw],Dlist2[idcontrol_dw]],
                [fz[idcontrol_dw],fz[idcontrol_dw]+1],'-g',linewidth=3)
        
        fig.legend(loc="center right",borderaxespad=0.05,frameon=False)
        
        plt.gca().set_aspect('equal', adjustable='box')
        plt.xlabel("Distance à l'axe théorique de plateforme(m)")
        plt.ylabel("Altitude(m)")        
        plt.grid(linewidth=0.6)
        plt.axis([xmin,xmax,min_elev,max_elev])
        plt.xticks(np.arange(int(xmin-0.5), int(xmax+0.5), 1.0))
        plt.yticks(np.arange(min_elev, max_elev+1, 1.0)) 
        plt.subplots_adjust(right=0.80,top=0.95)
               
        if save_fig and Ltron>0:
            fig.savefig(fig_name, dpi=fig.dpi)
        if show_fig:
            plt.show()
        plt.close()
    
    return Res,Pt_list


def get_profil_L(tr,i,Pt_list,Tab_xyz,dtmtree,surlargeur=0.5,z_tolerance=0.05,save_fig=False,Res_dir=None,show_fig=True):
    sl_list=np.array([0.67,1.0,1.5,4.0])
    #get segment param
    xpla,ypla,zpla = tr[0],tr[1], tr[2]
    xc,yc,zc = tr[3],tr[4],tr[5]
    x2,y2 = tr[6],tr[7]
    azfrom = calculate_azimut(xc, yc, xpla, ypla)  
    azto = tr[8]  
    dif = diff_az(azfrom,azto)
    sign=1 #center at the left side
    if abs((azto-dif)%360-azfrom)<0.1:
        sign*=-1 #center at right  side   
    road_width = tr[9]
    s_up = tr[10]/100.
    s_down = tr[11]/100.   
    slope_road,Ltron,idlac,idpt = tr[12],tr[13],int(tr[17]),int(tr[15])
    
    #build profile   
    Dhor,z,distance=build_prof(x2,y2,xc,yc,Tab_xyz,dtmtree)    
    fz = interpolate.interp1d(Dhor, z, kind='slinear')    
    step2 = 0.01
    Dlist  = np.arange(0,distance,step2)
    fz = fz(Dlist)                      
    Dc = round(np.sqrt((xpla-xc)*(xpla-xc)+(ypla-yc)*(ypla-yc)),2)   
    idC = int(Dc/step2)
    
    zroad = np.copy(fz) 
    id_in =  int((Dc-0.5*road_width)/step2) 
    id_out =  int((Dc+0.5*road_width+surlargeur)/step2) 
    Dleft = Dlist[id_in]
    slope = (zpla-zc)/Dleft
    zroad[0:id_in]=zc+slope*Dlist[0:id_in] 
    zroad[id_in:id_out+1]=zpla
    
    
    ###get transversal slope  
    Dr = min(Dc+6,distance)
    zr = fz[int(Dr/step2)]
    #get excavated width
    slope_left = (fz[0]-zpla)/Dc
    slope_right = (zr-zpla)/(Dr-Dc)
    
    idcross,test2 = get_profile_intersection2bis(fz[id_out:],zpla,0,step2,z_tolerance)  
    if idcross*step2<max(0.5*road_width,2) and test2:
        #on continue la plateforme
        idcross+=id_out
        zroad[id_out:idcross+1]=zpla
        sup_id=-1
    else:
        Dfrom = Dlist-Dlist[id_out]        
        if slope_right<0: # apply down slope  
            sup_id = get_slope_id(s_down)
            zroad[id_out:] = zpla-s_down*Dfrom[id_out:]            
            idcross,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance) 
            while test2==0:
                sup_id+=1
                if sup_id==4:
                    break
                zroad[id_out:] = zpla-sl_list[sup_id]*Dfrom[id_out:]  
                idcross,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance)
            if not test2:
                sup_id = get_slope_id(s_down)
                zroad[id_out:] = zpla+s_down*Dfrom[id_out:]  
                idcross,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance)
        else: # apply up slope
            sup_id = get_slope_id(s_up)
            zroad[id_out:] = zpla+s_up*Dfrom[id_out:]
            idcross,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance) 
            while test2==0:
                sup_id+=1
                if sup_id==4:
                    break
                zroad[id_out:] = zpla+sl_list[sup_id]*Dfrom[id_out:]  
                idcross,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance) 
            if not test2:
                sup_id = get_slope_id(s_up)
                zroad[id_out:] = zpla-s_up*Dfrom[id_out:]  
                idcross,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance)
        idcross+=id_out
        zroad[idcross:]=fz[idcross:]
      

    #####Recupere les points de rupture          
    if sign>0 : 
        g1=0        
        g2 = id_in
        d2 = id_out   
        d1 = idcross           
        
    else:
        g1 = idcross  
        g2 = id_out
        d2 = id_in
        d1 = 0
        
    Pt_list[i,0:2] = get_coord_pt_niv2(tr,Dlist[g1])  
    Pt_list[i,2:4] = get_coord_pt_niv2(tr,Dlist[g2]) 
    center = int(0.5*(g2+d2))
    #check if there is level point within extent
    idcross2,test2 = get_profile_intersection2bis(fz[1:idcross],zroad[1:idcross],center-1,step2,z_tolerance)
    if test2:
        Pt_list[i,4:6]=get_coord_pt_niv2(tr,Dlist[idcross2])
        Pt_list[i,6]=round(fz[idcross2],2)
        if idcross2<id_in :
            if sign>0:
                Pt_list[i,15]=2
            else:
                Pt_list[i,15]=3
        elif idcross2>id_out :
            if sign>0:
                Pt_list[i,15]=3
            else:
                Pt_list[i,15]=2
        else:
            Pt_list[i,15]=1      
        sumin = np.sum(zroad[0:idcross2+1]-fz[0:idcross2+1]) 
        if abs(sumin)<=z_tolerance:
            sumin = 0        
        sumout = np.sum(zroad[idcross2:idcross+1]-fz[idcross2:idcross+1]) 
        if abs(sumout)<=z_tolerance:
            sumout = 0    
        if sign>0:
            Pt_list[i,16]=sumin
            Pt_list[i,17]=sumout
        else:
            Pt_list[i,16]=sumout
            Pt_list[i,17]=sumin
            
    else:
        sumdif = np.sum(zroad[0:idcross+1]-fz[0:idcross+1]) 
        Pt_list[i,16]=sumdif
        Pt_list[i,17]=sumdif
        Pt_list[i,4:7] = -2,-2,-2
               
    Pt_list[i,7:9] = xpla,ypla
    Pt_list[i,9]=zpla
    Pt_list[i,10]=round(zpla-fz[idC],2)
    Pt_list[i,11:13] = get_coord_pt_niv2(tr,Dlist[d2])
    Pt_list[i,13:15] = get_coord_pt_niv2(tr,Dlist[d1])
    Pt_list[i,19] = idpt
                  
    #section en deblais
    tp = (fz-zroad)>0
    s_deb = np.sum(fz[tp]-zroad[tp])*step2
    # zroad2 = np.ones_like(zroad[idD1:idD2+1])*min(fz[idD],zplat) 
    if np.sum(tp)>0:
        assiet_deb = step2*np.sum(tp)
        assise_deb = np.sum(tp[id_in:id_out])*step2    
    else:
        assiet_deb=0
        assise_deb=0
    
    #section en remblais
    tp = (fz-zroad)<0    
    s_remb = np.sum(zroad[tp]-fz[tp])*step2
    if np.sum(tp)>0:
        assiet_remb  = step2*np.sum(tp)  
        assise_remb = np.sum(tp[id_in:id_out])*step2    
        if assise_remb+assise_deb!=road_width+surlargeur:
            assise_remb = road_width+surlargeur-assise_deb
    else:
        assiet_remb=0
        assise_remb=0
       
    #emprise          
    emprise = round(idcross*step2,2)
           
    Res = np.zeros((23,))
    #ID_PT ID_SEG L_TRON PT_LONG PT_G PT_D L_ASSIS ASSIS_DEB SEC_DEB V_DEB
    #0     1      2      3       4    5    6       7         8       9
    #ASSIS_REMB S_REMB V_REMB ASSIET_DEB ASSIET_REMB EMPRISE PT_REEL CONFIG
    #10         11     12     13         14          15      16      17
    #TAL_AMONT TAL_AVAL MODIF_AMONT PIQ_CONTROL
    #18        19       20          21
    
    Res[0:6]=idpt,idlac,Ltron,round(slope_road*100,1),round(slope_left*100,1),round(slope_right*100,1)
    if np.sum(zroad==zpla)*step2>road_width+surlargeur+0.01:
        Res[6]=round(np.sum(zroad==zpla)*step2,2)
    else:
        Res[6]=road_width+surlargeur
    Res[7:10]=round(assise_deb,2),round(s_deb,5),round(s_deb*Ltron,2)
    Res[10:13]=round(assise_remb,2),round(s_remb,5),round(s_remb*Ltron,2)
    Res[13:18]=round(assiet_deb,2),round(assiet_remb,2),emprise,tr[16],10
    sl_l = (zc-zpla)/Dc
    if sl_l>0:
        Res[18]=abs(int(sl_l*100+0.5))
        if sup_id!=-1:
            Res[19]=abs(sl_list[sup_id]*100)
            if sl_list[sup_id]*100!=s_down*100:
                Res[20]=1
        else:
            Dr = min(idcross*step2+6,distance)
            zr = fz[int(Dr/step2)]
            #get excavated width            
            Res[19]=abs(round((zr-zpla)/(Dr-Dc),4)*100)
            Res[20]=1
    else:
        Res[19]=abs(int(sl_l*100+0.5))
        if sup_id!=-1:
            Res[18]=abs(sl_list[sup_id]*100)
            if sl_list[sup_id]*100!=s_up*100:
                Res[20]=1
        else:
            Dr = min(idcross*step2+6,distance)
            zr = fz[int(Dr/step2)]
            #get excavated width            
            Res[18]=abs(round((zr-zpla)/(Dr-Dc),4)*100)
            Res[20]=1
        
    idbt = idcross     
    itera=0
    lpiq=0
    while itera < 1/step2 and lpiq<1:
        itera+=1
        if (idcross+itera)*step2>distance:
            lpiq=distance
            itera-=1
            break
        else:
            lpiq=math.sqrt((Dlist[idbt+itera]-Dlist[idbt])**2+(fz[idbt]-fz[idbt+itera])**2)
        
    idcontrol=idbt+itera      
    if fz[d1]>zpla==1:
        Res[21]=round(math.sqrt((Dc-Dlist[idcontrol])**2+(fz[idcontrol]-zpla)**2),2)
        Res[22]=-1 
    else:
        Res[22]=round(math.sqrt((Dc-Dlist[idcontrol])**2+(fz[idcontrol]-zpla)**2),2)
        Res[21]=-1 
    
    ptrav = abs((fz[idcontrol]-zc)/(step2*idcontrol))
    
    #plot   
    if show_fig or save_fig:     
        
        pente_trav = QCoreApplication.translate('Pente en travers: ')+str(int(ptrav*100+0.5))+"%"
        tal_amont = QCoreApplication.translate('Talus amont: ')+str(abs(int(Res[18])))+"%"
        tal_aval = QCoreApplication.translate('Talus aval: ')+str(abs(int(Res[19])))+"%"
       
        fig_title = "Point "+str(idpt)+" - Lacet "+str(idlac)
        fig_name = Res_dir+"Profils/"+"Pt"+str(idpt)+"_Lacet_"+str(idlac)+".png"
        
        idmax = int(idcross+1.5/step2)
        
        min_elev=int(min(np.min(fz[:idmax]),zpla,zc)-1.5)
        max_elev=int(max(np.max(fz[:idmax]),zpla,zc)+2.5)
        base_reg=min_elev
        plt.ioff()
        fig, ax = plt.subplots(1, 1, figsize=(12,8)) 
        fig.suptitle(fig_title)        
        Dlist2 = sign*(Dlist[:idmax]-Dlist[idC])
        miD,maD = np.min(Dlist2),np.max(Dlist2)
        #write slopes
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=pente_trav)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=tal_amont)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=tal_aval)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        
        #terrain profile
        ax.plot(Dlist2,fz[:idmax],color=mcd.XKCD_COLORS["xkcd:brown"],label=None)    
        ax.fill_between(Dlist2,fz[:idmax],base_reg,color=mcd.XKCD_COLORS["xkcd:brown"],alpha=0.1,label=None)
        #theoretical center axis and elevation of road
        ax.plot([miD,maD],[zpla,zpla],':k',linewidth=2.,label=None)
        ax.plot([0,0],[min_elev,max_elev],':k',linewidth=2,label="Axe/alt. centre plateforme")
        #level point
        # if config<5:
        #     ax.plot([Dlist2[idD],Dlist2[idD]],[min_elev,max_elev],'--b',label="Axe de niveau")
        # ax.fill_between([0-xy_tol,0-xy_tol,0+xy_tol,0+xy_tol],
        #                   [min_elev,max_elev,max_elev,min_elev],base_reg,
        #                   color=mcd.XKCD_COLORS["xkcd:salmon"],alpha=0.1,label="Zone tampon")
        
        #draw terrain after work
        ax.plot(Dlist2,zroad[:idmax],c='#CC79A7',linewidth=2,label="Profil après déblai/remblai")
        #draw plateforme
        ax.plot(Dlist2[id_in+8:id_out-7],zroad[id_in+8:id_out-7],c='#D55E00',linewidth=7,label="Plateforme")
        #Piquet control
        ax.plot([Dlist2[idcontrol],Dlist2[idcontrol]],
                [fz[idcontrol],fz[idcontrol]+1],'#009E73',linewidth=3,label="Piquet contrôle")
        #Center of lace turn
        ax.scatter(Dlist2[0],zc,s=60,c='#0072B2',marker="p",label="Centre du lacet")
        
        fig.legend(loc="center right",borderaxespad=0.05,frameon=False)
        
        plt.gca().set_aspect('equal', adjustable='box')
        plt.xlabel("Distance à l'axe central de la plateforme (m)")
        plt.ylabel("Altitude (m)")        
        plt.grid(linewidth=0.6)
        plt.xticks(np.arange(int(miD)-1, int(maD+0.5)+1, 1.0))
        plt.yticks(np.arange(min_elev, max_elev+1, 1.0)) 
        plt.subplots_adjust(right=0.80,top=0.95)
               
        if save_fig and Ltron>0:
            fig.savefig(fig_name, dpi=fig.dpi)
        if show_fig:
            plt.show()
        plt.close()
    
    return Res,Pt_list


def get_profil_L2(tr,i,Pt_list,Tab_xyz,dtmtree,surlargeur=0.5,z_tolerance=0.05,save_fig=False,Res_dir=None,show_fig=True):
    sl_list=np.array([0.67,1.0,1.5,4.0])
    #get segment param
    xpla,ypla,zpla = tr[0],tr[1], tr[2]
    x1,y1 = tr[3],tr[4]
    x2,y2 = tr[6],tr[7] 
    road_width = tr[9]
    s_up = tr[10]/100.
    s_down = tr[11]/100.   
    slope_road,Ltron,idlac,idpt = tr[12],tr[13],int(tr[17]),int(tr[15])
    
    #build profile   
    Dhor,z,distance=build_prof(x1,y1,x2,y2,Tab_xyz,dtmtree)    
    fz = interpolate.interp1d(Dhor, z, kind='slinear')    
    step2 = 0.01
    Dlist  = np.arange(0,distance,step2)
    fz = fz(Dlist)                      
    Dc = round(np.sqrt((xpla-x2)*(xpla-x2)+(ypla-y2)*(ypla-y2)),2)   
    idC = int(Dc/step2)
    
    zroad = np.copy(fz) 
    id_in =  int((Dc-0.5*road_width)/step2) 
    id_out =  int((Dc+0.5*road_width+surlargeur)/step2)     
    zroad[id_in:id_out+1]=zpla    
    ###get transversal slope  
    Dl = max(Dc-6,0)
    zl = fz[int(Dl/step2)]
    Dr = min(Dc+6,distance)
    zr = fz[int(Dr/step2)]
    #get excavated width
    slope_left = (zl-zpla)/(Dc-Dl)
    slope_right = (zr-zpla)/(Dr-Dc)
    
    #get left intersection
    idleft,test2 = get_profile_intersection2bis(fz[0:id_in],zpla,id_in,step2,z_tolerance) 
    if abs(idleft-id_in)*step2<max(0.5*road_width,2) and test2:
        #on continue la plateforme
        zroad[idleft:id_in]=zpla
        sup_id=-1
    else:
        Dfrom = Dlist-Dlist[id_in] 
        if slope_left>=0:
            sup_id = get_slope_id(s_up)
            zroad[0:id_in] = zpla-s_up*Dfrom[0:id_in]            
            idleft,test2 = get_profile_intersection2bis(fz[0:id_in],zroad[0:id_in],id_in,step2,z_tolerance) 
            while test2==0:
                sup_id+=1
                if sup_id==4:
                    break
                zroad[0:id_in] = zpla-s_up*Dfrom[0:id_in]            
                idleft,test2 = get_profile_intersection2bis(fz[0:id_in],zroad[0:id_in],id_in,step2,z_tolerance) 
            if not test2:
                sup_id = get_slope_id(s_up)
                zroad[0:id_in] = zpla+s_up*Dfrom[0:id_in]            
                idleft,test2 = get_profile_intersection2bis(fz[0:id_in],zroad[0:id_in],id_in,step2,z_tolerance) 
                
        else:        
            sup_id = get_slope_id(s_down)
            zroad[0:id_in] = zpla+s_down*Dfrom[0:id_in]            
            idleft,test2 = get_profile_intersection2bis(fz[0:id_in],zroad[0:id_in],id_in,step2,z_tolerance) 
            while test2==0:
                sup_id+=1
                if sup_id==4:
                    break
                zroad[0:id_in] = zpla+s_down*Dfrom[0:id_in]            
                idleft,test2 = get_profile_intersection2bis(fz[0:id_in],zroad[0:id_in],id_in,step2,z_tolerance) 
            if not test2:
                sup_id = get_slope_id(s_down)
                zroad[0:id_in] = zpla-s_down*Dfrom[0:id_in]            
                idleft,test2 = get_profile_intersection2bis(fz[0:id_in],zroad[0:id_in],id_in,step2,z_tolerance) 
        zroad[0:idleft]=fz[0:idleft]
    
    #get righ intersection 
    id_right,test2 = get_profile_intersection2bis(fz[id_out:],zpla,0,step2,z_tolerance)  
    if id_right*step2<max(0.5*road_width,2) and test2:
        #on continue la plateforme
        id_right+=id_out
        zroad[id_out:id_right+1]=zpla
        sup_id=-1
    else:
        Dfrom = Dlist-Dlist[id_out]        
        if slope_right<0: # apply down slope  
            sup_id = get_slope_id(s_down)
            zroad[id_out:] = zpla-s_down*Dfrom[id_out:]            
            id_right,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance) 
            while test2==0:
                sup_id+=1
                if sup_id==4:
                    break
                zroad[id_out:] = zpla-sl_list[sup_id]*Dfrom[id_out:]  
                id_right,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance)
            if not test2:
                sup_id = get_slope_id(s_down)
                zroad[id_out:] = zpla+s_down*Dfrom[id_out:]  
                id_right,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance)
        else: # apply up slope
            sup_id = get_slope_id(s_up)
            zroad[id_out:] = zpla+s_up*Dfrom[id_out:]
            id_right,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance) 
            while test2==0:
                sup_id+=1
                if sup_id==4:
                    break
                zroad[id_out:] = zpla+sl_list[sup_id]*Dfrom[id_out:]  
                id_right,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance) 
            if not test2:
                sup_id = get_slope_id(s_up)
                zroad[id_out:] = zpla-s_up*Dfrom[id_out:]  
                id_right,test2 = get_profile_intersection2bis(fz[id_out:],zroad[id_out:],0,step2,z_tolerance)
        id_right+=id_out
        zroad[id_right:]=fz[id_right:]
      
    #####Recupere les points de rupture     
    d1 = id_right  
    d2 = id_out
    g2 = id_in
    g1 = idleft
            
    Pt_list[i,0:2] = get_coord_pt_niv(tr,Dlist[g1])  
    Pt_list[i,2:4] = get_coord_pt_niv(tr,Dlist[g2])  
    center = int(0.5*(g2+d2))
    #check if there is level point within extent
    idcross2,test2 = get_profile_intersection2bis(fz[idleft+1:id_right],zroad[idleft+1:id_right],center-(idleft+1),step2,z_tolerance)
    if test2:
        idcross2+=idleft+1
        Pt_list[i,4:6]=get_coord_pt_niv(tr,Dlist[idcross2])
        Pt_list[i,6]=round(fz[idcross2],2)
        if idcross2<id_in :
            Pt_list[i,15]=2           
        elif idcross2>id_out :            
            Pt_list[i,15]=3            
        else:
            Pt_list[i,15]=1      
        sumin = np.sum(zroad[0:idcross2+1]-fz[0:idcross2+1]) 
        if abs(sumin)<=z_tolerance:
            sumin = 0        
        sumout = np.sum(zroad[idcross2:id_right+1]-fz[idcross2:id_right+1]) 
        if abs(sumout)<=z_tolerance:
            sumout = 0    
        
        Pt_list[i,16]=sumin
        Pt_list[i,17]=sumout       
            
    else:
        sumdif = np.sum(zroad[idleft:id_right+1]-fz[idleft:id_right+1]) 
        Pt_list[i,16]=sumdif
        Pt_list[i,17]=sumdif
        Pt_list[i,4:7] = -2,-2,-2
               
    Pt_list[i,7:9] = xpla,ypla
    Pt_list[i,9]=zpla
    Pt_list[i,10]=round(zpla-fz[idC],2)
    Pt_list[i,11:13] = get_coord_pt_niv(tr,Dlist[d2])
    Pt_list[i,13:15] = get_coord_pt_niv(tr,Dlist[d1])
    Pt_list[i,19] = idpt
                  
    #section en deblais
    tp = (fz-zroad)>0
    s_deb = np.sum(fz[tp]-zroad[tp])*step2
    # zroad2 = np.ones_like(zroad[idD1:idD2+1])*min(fz[idD],zplat) 
    if np.sum(tp)>0:
        assiet_deb = step2*np.sum(tp)
        assise_deb = np.sum(tp[id_in:id_out])*step2    
    else:
        assiet_deb=0
        assise_deb=0
    
    #section en remblais
    tp = (fz-zroad)<0    
    s_remb = np.sum(zroad[tp]-fz[tp])*step2
    if np.sum(tp)>0:
        assiet_remb  = step2*np.sum(tp)  
        assise_remb = np.sum(tp[id_in:id_out])*step2    
        if assise_remb+assise_deb!=road_width+surlargeur:
            assise_remb = road_width+surlargeur-assise_deb
    else:
        assiet_remb=0
        assise_remb=0
       
    #emprise          
    emprise = round((id_right-idleft)*step2,2)
           
    Res = np.zeros((23,))
    #ID_PT ID_SEG L_TRON PT_LONG PT_G PT_D L_ASSIS ASSIS_DEB SEC_DEB V_DEB
    #0     1      2      3       4    5    6       7         8       9
    #ASSIS_REMB S_REMB V_REMB ASSIET_DEB ASSIET_REMB EMPRISE PT_REEL CONFIG
    #10         11     12     13         14          15      16      17
    #TAL_AMONT TAL_AVAL MODIF_AMONT PIQ_CONTROL
    #18        19       20          21
    
    Res[0:6]=idpt,idlac,Ltron,round(slope_road*100,1),round(slope_left*100,1),round(slope_right*100,1)
    if np.sum(zroad==zpla)*step2>road_width+surlargeur+0.01:
        Res[6]=round(np.sum(zroad==zpla)*step2,2)
    else:
        Res[6]=road_width+surlargeur
    Res[7:10]=round(assise_deb,2),round(s_deb,5),round(s_deb*Ltron,2)
    Res[10:13]=round(assise_remb,2),round(s_remb,5),round(s_remb*Ltron,2)
    Res[13:18]=round(assiet_deb,2),round(assiet_remb,2),emprise,2,10
    
    #calc slope of talus
    try:
        sl_l = int(abs(100*round((fz[idleft]-zpla)/((id_in-idleft)*step2),1)))
    except:
        idleftbis = max(0,idleft-int(2/step2))
        sl_l = int(abs(100*round((fz[idleftbis]-zpla)/2,1)))
    try:              
        sl_r = int(abs(100*round((fz[id_right]-zpla)/((id_right-id_out)*step2),1)))
    except:
        idrightbis = min(Dlist.shape[0]-1,id_right+int(2/step2))
        sl_r = int(abs(100*round((fz[idrightbis]-zpla)/2,1)))
      
    if slope_left>0:
        Res[18]=sl_l 
        Res[19]=sl_r 
        if sl_l/100!=s_up:
            Res[20]=1
    else:
        Res[19]=sl_l 
        Res[18]=sl_r 
        if sl_r/100!=s_up:
            Res[20]=1
             
    #Piquet control gauche
    idbt = idleft
    itera=0
    lpiq=0
    while itera < 1/step2 and lpiq<1 and (idbt-itera)>0:
        itera+=1       
        lpiq=math.sqrt((Dlist[idbt-itera]-Dlist[idbt])**2+(fz[idbt]-fz[idbt-itera])**2)
    idcontrol_left = idbt-itera 
     
    #Piquet control droite
    idbt = id_right     
    itera=0
    lpiq=0
    while itera < 1/step2 and lpiq<1:
        itera+=1
        if (id_right+itera)*step2>distance:
            lpiq=distance
            itera-=1
            break
        else:
            lpiq=math.sqrt((Dlist[idbt+itera]-Dlist[idbt])**2+(fz[idbt]-fz[idbt+itera])**2)
        
    idcontrol_right=idbt+itera      
    
    if fz[idcontrol_left]>fz[idcontrol_right]:
        idcontrol_up=idcontrol_left
        idcontrol_dw=idcontrol_right
    else:
        idcontrol_up=idcontrol_right
        idcontrol_dw=idcontrol_left
   
    Res[21]=round(math.sqrt((Dc-Dlist[idcontrol_up])**2+(fz[idcontrol_up]-zpla)**2),2)
    Res[22]=round(math.sqrt((Dc-Dlist[idcontrol_dw])**2+(fz[idcontrol_dw]-zpla)**2),2) 
    
    ptrav = abs((fz[idcontrol_up]-fz[idcontrol_dw])/(step2*(idcontrol_right-idcontrol_left)))
    
    #plot   
    if show_fig or save_fig:     
        
        pente_trav = QCoreApplication.translate('Pente en travers: ')+str(int(ptrav*100+0.5))+"%"
        tal_amont = QCoreApplication.translate('Talus amont: ')+str(abs(int(Res[18])))+"%"
        tal_aval = QCoreApplication.translate('Talus aval: ')+str(abs(int(Res[19])))+"%"
       
        fig_title = "Point "+str(idpt)+" - Lacet "+str(idlac)
        fig_name = Res_dir+"Profils/"+"Pt"+str(idpt)+"_Lacet_"+str(idlac)+".png"
        
        idmax = int(id_right+1.5/step2)
        idmin = int(idleft-1.5/step2)
        
        min_elev=int(min(np.min(fz[idmin:idmax]),zpla)-1.5)
        max_elev=int(max(np.max(fz[idmin:idmax]),zpla)+2.5)
        base_reg=min_elev
        plt.ioff()
        fig, ax = plt.subplots(1, 1, figsize=(12,8)) 
        fig.suptitle(fig_title)        
        Dlist2 = Dlist[idmin:idmax]-Dlist[idC]
        Dlist3 = Dlist-Dlist[idC]
        miD,maD = np.min(Dlist2),np.max(Dlist2)
        #write slopes
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=pente_trav)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=tal_amont)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=tal_aval)
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        ax.plot(0,min_elev,marker="x",markeredgecolor = 'white',color="white",label=" ")
        
        #terrain profile
        ax.plot(Dlist2,fz[idmin:idmax],color=mcd.XKCD_COLORS["xkcd:brown"],label=None)    
        ax.fill_between(Dlist2,fz[idmin:idmax],base_reg,color=mcd.XKCD_COLORS["xkcd:brown"],alpha=0.1,label=None)
        #theoretical center axis and elevation of road
        ax.plot([miD,maD],[zpla,zpla],':k',linewidth=2.,label=None)
        ax.plot([0,0],[min_elev,max_elev],':k',linewidth=2,label="Axe/alt. centre plateforme")
        #level point
        # if config<5:
        #     ax.plot([Dlist2[idD],Dlist2[idD]],[min_elev,max_elev],'--b',label="Axe de niveau")
        # ax.fill_between([0-xy_tol,0-xy_tol,0+xy_tol,0+xy_tol],
        #                   [min_elev,max_elev,max_elev,min_elev],base_reg,
        #                   color=mcd.XKCD_COLORS["xkcd:salmon"],alpha=0.1,label="Zone tampon")
        
        #draw terrain after work
        ax.plot(Dlist2,zroad[idmin:idmax],c='#CC79A7',linewidth=2,label="Profil après déblai/remblai")
        #draw plateforme
        ax.plot(Dlist3[id_in+8:id_out-7],zroad[id_in+8:id_out-7],c='#D55E00',linewidth=7,label="Plateforme")
        #Piquet control amont
        ax.plot([Dlist3[idcontrol_up],Dlist3[idcontrol_up]],
                [fz[idcontrol_up],fz[idcontrol_up]+1],'-g',linewidth=3,label="Piquets contrôles")
        #Piquet control amont
        ax.plot([Dlist3[idcontrol_dw],Dlist3[idcontrol_dw]],
                [fz[idcontrol_dw],fz[idcontrol_dw]+1],'-g',linewidth=3)
        #Center of lace turn
        #ax.scatter(Dlist2[0],zc,s=60,c='#0072B2',marker="p",label="Centre du lacet")
        
        fig.legend(loc="center right",borderaxespad=0.05,frameon=False)
        
        plt.gca().set_aspect('equal', adjustable='box')
        plt.xlabel("Distance à l'axe central de la plateforme (m)")
        plt.ylabel("Altitude (m)")        
        plt.grid(linewidth=0.6)
        plt.xticks(np.arange(int(miD)-1, int(maD+0.5)+1, 1.0))
        plt.yticks(np.arange(min_elev, max_elev+1, 1.0)) 
        plt.subplots_adjust(right=0.80,top=0.95)
               
        if save_fig and Ltron>0:
            fig.savefig(fig_name, dpi=fig.dpi)
        if show_fig:
            plt.show()
        plt.close()
    
    return Res,Pt_list


def Distplan(y, x,yE, xE):
    return math.sqrt((y-yE)*(y-yE)+(x-xE)*(x-xE))


def Distplan3D(y, x,z,yE, xE,zE):
    Dh = math.sqrt((y-yE)*(y-yE)+(x-xE)*(x-xE))
    return math.sqrt((z-zE)*(z-zE)+Dh**2)


def save_Tab_init(Tab,Res_dir,Pt_list,pt_analyse,max_exca_slope):  
    tp = Tab[:,16]>0
    Tab2 = Tab[tp]
    Pt_list2 = Pt_list[tp]
    pt_analyse2 = pt_analyse[tp]
    
    AzD = np.zeros((Tab2.shape[0],7),dtype=np.float32)
    AzD[:,0:2] = -1
    AzD[:,5:] = -1
    #Azto_niv D_niv Azto_C D_C Lapp Plong_niv Plong_c
    #0        1     2      3   4    5         6      
    
    #Recompute azimut and lapp
    nbpt = np.sum(tp)    
    Lseg=0
    for i in range(nbpt-1):    
        #Repetitive point
        if Tab2[i+1,0]==Tab2[i,0]: 
             #Recompute xc,yc,zc,dzc
             p1_x,p1_y,p1_z,p1_dz = Pt_list2[i,7:11]
             p2_x,p2_y,p2_z,p2_dz = Pt_list2[i+1,7:11]
             Pt_list2[i,7]=0.5*(p1_x+p2_x)
             Pt_list2[i+1,7]=0.5*(p1_x+p2_x)
             Pt_list2[i,8]=0.5*(p1_y+p2_y)
             Pt_list2[i+1,8]=0.5*(p1_y+p2_y)
             Pt_list2[i,9]=0.5*(p1_z+p2_z)
             Pt_list2[i+1,9]=0.5*(p1_z+p2_z)
             Pt_list2[i,1]=0.5*(p1_dz+p2_dz)
             Pt_list2[i+1,10]=0.5*(p1_dz+p2_dz)            
        else:
            if Pt_list2[i+1,15]==1:  
                AzD[i,0] = calculate_azimut(Pt_list2[i,4],Pt_list2[i,5],Pt_list2[i+1,4],Pt_list2[i+1,5])  
                AzD[i,1] = Distplan3D(Pt_list2[i,5],Pt_list2[i,4],Pt_list2[i,6],Pt_list2[i+1,5],Pt_list2[i+1,4],Pt_list2[i+1,6])                
                D = Distplan(Pt_list2[i,4],Pt_list2[i,5],Pt_list2[i+1,4],Pt_list2[i+1,5])
                if D!=0:
                    AzD[i,5] = round((Pt_list2[i+1,6]-Pt_list2[i,6])/D*100,1)                
            AzD[i,2] = calculate_azimut(Pt_list2[i,7],Pt_list2[i,8],Pt_list2[i+1,7],Pt_list2[i+1,8])
            Lseg2= Distplan(Pt_list2[i,8],Pt_list2[i,7],Pt_list2[i+1,8],Pt_list2[i+1,7])
            AzD[i,3] = Distplan3D(Pt_list2[i,8],Pt_list2[i,7],Pt_list2[i,9],Pt_list2[i+1,8],Pt_list2[i+1,7],Pt_list2[i+1,9])
            if Lseg2!=0:
                AzD[i,6] = round((Pt_list2[i+1,9]-Pt_list2[i,9])/Lseg2*100,1)          
            if Tab2[i-1,0]==Tab2[i,0]:
                AzD[i-1,2:4]=AzD[i,2:4]
                AzD[i-1,4]=0.5*Lseg
                AzD[i,4]=0.5*Lseg2
                AzD[i-1,6]=AzD[i,6]
                if AzD[i,1]>0:
                    AzD[i-1,:2]=AzD[i,:2]
                    AzD[i-1,5]=AzD[i,5]
            else:
                AzD[i,4] = 0.5*(Lseg+Lseg2)
            Lseg=Lseg2
    AzD[-1,4]=0.5*Lseg
        
    #Compute Volume
    Tab2[:,9]=np.round(Tab2[:,8]*AzD[:,4],2)    
    Tab2[:,12]=np.round(Tab2[:,11]*AzD[:,4],2)   
    Tab2[:,2]=np.round(AzD[:,4],2)
    Tab2[:,7]=np.minimum(Tab2[:,6],Tab2[:,7])
    Tab2[:,10]=np.minimum(Tab2[:,6],Tab2[:,10])    

    colname =  QCoreApplication.translate("MainWindow","Piquet;Type;Pente Gauche (%);")
    colname += QCoreApplication.translate("MainWindow","Pente Droite (%);Longueur applicable (m);Largeur assise (m);")
    colname += QCoreApplication.translate("MainWindow","Talus amont (%);Assise en déblai (m);Section en déblai (m²);Volume en déblai (m\u00B3);Volume à évacuer (m\u00B3);")
    colname += QCoreApplication.translate("MainWindow","% de roche;Volume de roche (m\u00B3);")
    colname += QCoreApplication.translate("MainWindow","Talus aval (%);Assise en remblai (m);Section en remblai (m²);Volume en remblai (m\u00B3);")
    colname += QCoreApplication.translate("MainWindow","Assiette en déblai (m);Assiette en remblai (m);Piquet contrôle amont (m);Piquet contrôle aval (m);Emprise (m);Surface emprise (m²);")
    colname += QCoreApplication.translate("MainWindow","Xniv;Yniv;Zniv;Azimut p. niveau suivant (grad);Distance réelle p. niveau suivant (m);Pente long p. niveau suivant (%);")
    colname +=QCoreApplication.translate("MainWindow","Xcen;Ycen;Zcen;Diff. altitude entre terrain p. central;Azimut p. central suivant (grad);Distance réelle p. central suivant (m);Pente long p. central suivant (%)\n")

    txt = colname
    scum=0
    vcum=0
    vroc=0

    for i,dt in enumerate(Tab2):      
        txt += str(int(dt[0]))
        if dt[16]==1:
            txt+=";Niveau"
        else:
            txt+=";Lacet_"+str(int(dt[1])) 
        for col in [4,5,2,6]:
            txt+=";"+str(round(dt[col],2))
        if dt[20]==1:
            txt+=";"+str(int(dt[18]))+"*"
        else:
            txt+=";"+str(int(dt[18]))
        for col in [7,8,9]:
            txt+=";"+str(round(dt[col],2))
        #######################################
        # ### Vevac
        # if dt[10]==0 or dt[17]==3 or dt[17]==6:
        #     vcum+=dt[9]
        #     txt+=";"+str(round(dt[9],2))
        # else:
        #     txt+=";0"
        ### Vevac
        if dt[10]==0 and max(abs(dt[4]),abs(dt[5]))>max_exca_slope:            
            vcum+=dt[9]
            txt+=";"+str(round(dt[9],2))
        elif dt[17]==3 and max(abs(dt[4]),abs(dt[5]))>max_exca_slope:
            vcum+=dt[9]
            txt+=";"+str(round(dt[9],2))
        elif dt[17]==6:
            vcum+=dt[9]
            txt+=";"+str(round(dt[9],2))
        else:
            txt+=";0"            
        #######################################
        #add proche
        proc = pt_analyse2[i,15]
        txt+=";"+str(int(proc+0.5))
        txt+=";"+str(round(dt[9]*proc/100,2))
        if proc>0:
            vroc+=dt[9]*proc/100
        #######################################
        txt+=";"+str(int(dt[19]))
        for col in [10,11,12,13,14,21,22,15]:  
            if dt[col]<0:
                txt+=";"
            else:
                txt+=";"+str(round(dt[col],2))
        semp = dt[2]*dt[15]
        scum += semp
        txt+=";"+str(round(semp,2))        
        if Pt_list2[i,15]==1:
            txt+=";"+str(round(Pt_list2[i,4],2))+";"+str(round(Pt_list2[i,5],2))+";"+str(round(Pt_list2[i,6],1))
            try:
                if Pt_list2[i+1,15]==1:
                    txt+=';'+str(int(AzD[i,0]*20/18.+0.5))+";"+str(round(AzD[i,1],1))
                    if str(AzD[i,5])!='-1':                       
                        txt+=';'+str(str(AzD[i,5]))
                    else:
                        txt+=';'                    
                else:
                    txt+=';;;'
            except:
                txt+=';;;'
        else:
            txt+=';;;;;;'      
        txt+=";"+str(round(Pt_list2[i,7],2))+";"+str(round(Pt_list2[i,8],2))+";"+str(round(Pt_list2[i,9],1))        
        txt+=";"+str(round(Pt_list2[i,10],1))
        if i <nbpt-1:
            txt+=";"+str(int(AzD[i,2]*20/18.+0.5))+";"+str(round(AzD[i,3],1))
            if str(AzD[i,6])!='-1':                       
                txt+=';'+str(str(AzD[i,6]))
            else:
                txt+=';' 
        else:
            txt+=';;;' 
        txt+='\n'

    ltot = str(round(np.sum(Tab2[:,2]),2))
    vdeb = str(round(np.sum(Tab2[:,9]),2))
    vevac = str(round(vcum,2))
    vremb = str(round(np.sum(Tab2[:,12]),2))
    semp = str(round(scum,2))
    vroc = str(round(vroc,2))

    txt+="TOTAL;;;;;"+ltot+";;;;;"
    txt+=vdeb+";"+vevac+";;"+vroc+";;;;"+vremb
    txt+=";;;;;;"+semp

    file_name=Res_dir+"Tab_cubature_pts_init.csv"

    with open(file_name, "w") as f:        
        f.write(txt)
        f.close()
    return ltot,vdeb,vevac,vremb,semp,vroc,Tab2[Tab2[:,17]==10]


def save_Tab_Lace(Tab2,Res_dir):  
    colname =  QCoreApplication.translate("MainWindow","Lacet;Volume en déblai (m\\u00B3);Volume en remblai (m\\u00B3);")
    colname += QCoreApplication.translate("MainWindow","Emprise en déblai (m²);Emprise en remblai (m²);Emprise totale (m²)\n")
    emp_deb = Tab2[:,13]*Tab2[:,2]
    emp_rem = Tab2[:,14]*Tab2[:,2] 
    
    txt = colname    
    val = np.unique(Tab2[:,1])
    for idlac in val:
        txt += str(int(idlac))+";"
        tp = Tab2[:,1]==idlac
        txt += str(round(np.sum(Tab2[tp,9]),1))+";" #vdeb
        txt += str(round(np.sum(Tab2[tp,12]),1))+";" #vdeb
        txt += str(round(np.sum(emp_deb[tp]),1))+";" #emp_deb
        txt += str(round(np.sum(emp_rem[tp]),1))+";" #emp_rem
        txt += str(round(np.sum(emp_deb[tp]+emp_rem[tp]),1))+"\n" #emp_rem
    
    vdeb = str(round(np.sum(Tab2[:,9]),1))    
    vremb = str(round(np.sum(Tab2[:,12]),1))
    semp_deb = str(round(np.sum(emp_deb),1))
    semp_rem = str(round(np.sum(emp_rem),1))
    semp = str(round(np.sum(emp_rem+emp_deb),1))
    txt+="TOTAL;"+vdeb+";"+vremb+";"+semp_deb+";"+semp_rem+";"+semp 
    
    file_name=Res_dir+"Tab_cubature_lacets.csv"
    
    with open(file_name, "w") as f:        
        f.write(txt)
        f.close()
    

def save_Tab(Tab,Res_dir,Pt_list,pt_analyse,max_exca_slope):  
    tp = Tab[:,0]>0
    Tab2 = Tab[tp]
    Pt_list2 = Pt_list[tp]
    pt_analyse2 = pt_analyse[tp]
    
    AzD = np.zeros((Tab2.shape[0],7),dtype=np.float32)
    AzD[:,0:2] = -1
    AzD[:,5:] = -1
    #Azto_niv D_niv Azto_C D_C Lapp Plong_niv Plong_c
    #0        1     2      3   4    5         6       
    
    #Recompute azimut and lapp
    nbpt = np.sum(tp)    
    Lseg=0
    for i in range(nbpt-1):    
        #Repetitive point
        if Tab2[i+1,0]==Tab2[i,0]: 
             p1_x,p1_y,p1_z,p1_dz = Pt_list2[i,7:11]
             p2_x,p2_y,p2_z,p2_dz = Pt_list2[i+1,7:11]
             Pt_list2[i,7]=0.5*(p1_x+p2_x)
             Pt_list2[i+1,7]=0.5*(p1_x+p2_x)
             Pt_list2[i,8]=0.5*(p1_y+p2_y)
             Pt_list2[i+1,8]=0.5*(p1_y+p2_y)
             Pt_list2[i,9]=0.5*(p1_z+p2_z)
             Pt_list2[i+1,9]=0.5*(p1_z+p2_z)
             Pt_list2[i,10]=0.5*(p1_dz+p2_dz)
             Pt_list2[i+1,10]=0.5*(p1_dz+p2_dz)   
        else:
            if Pt_list2[i+1,15]==1:  
                AzD[i,0] = calculate_azimut(Pt_list2[i,4],Pt_list2[i,5],Pt_list2[i+1,4],Pt_list2[i+1,5])  
                AzD[i,1] = Distplan3D(Pt_list2[i,5],Pt_list2[i,4],Pt_list2[i,6],Pt_list2[i+1,5],Pt_list2[i+1,4],Pt_list2[i+1,6])
                D = Distplan(Pt_list2[i,4],Pt_list2[i,5],Pt_list2[i+1,4],Pt_list2[i+1,5])
                if D!=0:
                    AzD[i,5] = round((Pt_list2[i+1,6]-Pt_list2[i,6])/D*100,1)                
            AzD[i,2] = calculate_azimut(Pt_list2[i,7],Pt_list2[i,8],Pt_list2[i+1,7],Pt_list2[i+1,8])
            Lseg2= Distplan(Pt_list2[i,8],Pt_list2[i,7],Pt_list2[i+1,8],Pt_list2[i+1,7])
            AzD[i,3] = Distplan3D(Pt_list2[i,8],Pt_list2[i,7],Pt_list2[i,9],Pt_list2[i+1,8],Pt_list2[i+1,7],Pt_list2[i+1,9])
            if Lseg2!=0:
                AzD[i,6] = round((Pt_list2[i+1,9]-Pt_list2[i,9])/Lseg2*100,1)          
            if Tab2[i-1,0]==Tab2[i,0]: 
                AzD[i-1,2:4]=AzD[i,2:4]
                AzD[i-1,4]=0.5*Lseg
                AzD[i,4]=0.5*Lseg2
                AzD[i-1,6]=AzD[i,6]
                if AzD[i,1]>0:
                    AzD[i-1,:2]=AzD[i,:2]
                    AzD[i-1,5]=AzD[i,5]
            else:
                AzD[i,4] = 0.5*(Lseg+Lseg2)
            Lseg=Lseg2
    AzD[-1,4]=0.5*Lseg
        
    #Compute Volume
    Tab2[:,9]=np.round(Tab2[:,8]*AzD[:,4],2)    
    Tab2[:,12]=np.round(Tab2[:,11]*AzD[:,4],2)   
    Tab2[:,2]=np.round(AzD[:,4],2)
    Tab2[:,7]=np.minimum(Tab2[:,6],Tab2[:,7])
    Tab2[:,10]=np.minimum(Tab2[:,6],Tab2[:,10])
    colname =  QCoreApplication.translate("MainWindow","Piquet;Type;Configuration;Pente Gauche (%);")
    colname += QCoreApplication.translate("MainWindow","Pente Droite (%);Longueur applicable (m);Largeur assise (m);")
    colname += QCoreApplication.translate("MainWindow","Talus amont (%);Assise en déblai (m);Section en déblai (m²);Volume en déblai (m\u00B3);Volume à évacuer (m\u00B3);")
    colname += QCoreApplication.translate("MainWindow","% de roche;Volume de roche (m\u00B3);")
    colname += QCoreApplication.translate("MainWindow","Talus aval (%);Assise en remblai (m);Section en remblai (m²);Volume en remblai (m\u00B3);")
    colname += QCoreApplication.translate("MainWindow","Assiette en déblai (m);Assiette en remblai (m);Piquet contrôle amont (m);Piquet contrôle aval (m);Emprise (m);Surface emprise (m²);")
    colname += QCoreApplication.translate("MainWindow","Xniv;Yniv;Zniv;Azimut p. niveau suivant (grad);Distance réelle p. niveau suivant (m);Pente long p. niveau suivant (%);")
    colname += QCoreApplication.translate("MainWindow","Xcen;Ycen;Zcen;Diff. altitude entre terrain p. central;Azimut p. central suivant (grad);Distance réelle p. central suivant (m);Pente long p. central suivant (%)\n")


    txt = colname
    scum=0
    vcum=0
    vroc=0
    for i,dt in enumerate(Tab2):
        txt += str(int(dt[0]))
        if dt[16]==1:
            piq=";Niveau;"+str(int(dt[17]))
        elif dt[16]==2:
            piq=";Lacet_"+str(int(dt[1])) +";"
        else:
            piq=";Supplementaire;"+str(int(dt[17]))
        txt+=piq
        for col in [4,5,2,6]:
            txt+=";"+str(round(dt[col],2))
        if dt[20]==1:
            txt+=";"+str(int(dt[18]))+"*"
        else:
            txt+=";"+str(int(dt[18]))
        for col in [7,8,9]:
            txt+=";"+str(round(dt[col],2))
        #######################################
        # ### Vevac
        # if dt[10]==0 or dt[17]==3 or dt[17]==6:
        #     vcum+=dt[9]
        #     txt+=";"+str(round(dt[9],2))
        # else:
        #     txt+=";0"
        ### Vevac        
        if dt[10]==0 and max(abs(dt[4]),abs(dt[5]))>max_exca_slope:        
            vcum+=dt[9]
            txt+=";"+str(round(dt[9],2))
        elif dt[17]==3 and max(abs(dt[4]),abs(dt[5]))>max_exca_slope:
            vcum+=dt[9]
            txt+=";"+str(round(dt[9],2))
        elif dt[17]==6:
            vcum+=dt[9]
            txt+=";"+str(round(dt[9],2))
        else:
            txt+=";0"            
        #######################################
        #add proche
        proc = pt_analyse2[i,15]
        txt+=";"+str(int(proc+0.5))
        txt+=";"+str(round(dt[9]*proc/100,2))
        if proc>0:
            vroc+=dt[9]*proc/100
        #######################################
        
        txt+=";"+str(int(dt[19]))
        for col in [10,11,12,13,14,21,22,15]:  
            if dt[col]<0:
                txt+=";"
            else:
                txt+=";"+str(round(dt[col],2))
        semp = dt[2]*dt[15]
        scum += semp
        txt+=";"+str(round(semp,2))        
        if Pt_list2[i,15]==1:
            txt+=";"+str(round(Pt_list2[i,4],2))+";"+str(round(Pt_list2[i,5],2))+";"+str(round(Pt_list2[i,6],1))
            try:
                if Pt_list2[i+1,15]==1 and AzD[i,1]>0:                
                    txt+=';'+str(int(AzD[i,0]*20/18.+0.5))+";"+str(round(AzD[i,1],1))
                    if str(AzD[i,5])!='-1':                       
                        txt+=';'+str(str(AzD[i,5]))
                    else:
                        txt+=';'    
                else:
                    txt+=';;;'
            except:
                txt+=';;;'
        else:
            txt+=';;;;;;'
        txt+=";"+str(round(Pt_list2[i,7],2))+";"+str(round(Pt_list2[i,8],2))+";"+str(round(Pt_list2[i,9],1))        
        txt+=";"+str(round(Pt_list2[i,10],1))
        if i <nbpt-1:
            txt+=";"+str(int(AzD[i,2]*20/18.+0.5))+";"+str(round(AzD[i,3],1))
            if str(AzD[i,6])!='-1':                       
                txt+=';'+str(str(AzD[i,6]))
            else:
                txt+=';' 
        else:
            txt+=';;;' 
        txt+='\n'
        
    ltot = str(round(np.sum(Tab2[:,2]),2))
    vdeb = str(round(np.sum(Tab2[:,9]),2))
    vevac = str(round(vcum,2))
    vremb = str(round(np.sum(Tab2[:,12]),2))
    semp = str(round(scum,2))
    vroc = str(round(vroc,2))
    
    txt+="TOTAL;;;;;;"+ltot+";;;;;"
    txt+=vdeb+";"+vevac+";;"+vroc+";;;;"+vremb
    txt+=";;;;;;"+semp
    
    file_name=Res_dir+"Tab_cubature_pts_tous.csv"
    
    with open(file_name, "w") as f:        
        f.write(txt)
        f.close()
    return ltot,vdeb,vevac,vremb,semp,vroc


def get_param(Dtm_file ,Road_file,step,max_exca_slope,min_exca_slope,
              xy_tolerance,Csize,save_shp,save_fig,from_Sylvaroad,Radius,angle_hairpin):
    
    if step == None:
        str_stp = QCoreApplication.translate("MainWindow","Aucun, analyse à chaque sommet de la couche desserte\n")
    else:
        str_stp = str(step)+" m\n"
        
    if xy_tolerance == None:
        str_xy = QCoreApplication.translate("MainWindow","0.5 x Largeur de plateforme\n")
    else:
        str_xy = str(xy_tolerance)+" m\n"
        
    if save_fig:
        str_fig = QCoreApplication.translate("MainWindow","Oui\n")
    else:
        str_fig = QCoreApplication.translate("MainWindow","Non\n")
        
    if save_shp:
        str_shp = QCoreApplication.translate("MainWindow","Oui\n")
    else:
        str_shp = QCoreApplication.translate("MainWindow","Non\n")
    
    txt = QCoreApplication.translate("MainWindow","FICHIERS UTILISES POUR LA MODELISATION:\n\n")
    txt += QCoreApplication.translate("MainWindow","   - MNT :                 ") + Dtm_file+"\n"
    txt += QCoreApplication.translate("MainWindow","     Résolution (m) :      ")+str(Csize)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Couche Desserte :     ") + Road_file+"\n\n\n"
    
    
    txt += QCoreApplication.translate("MainWindow","PARAMETRES UTILISES POUR LA MODELISATION:\n\n")
    txt += QCoreApplication.translate("MainWindow","   - Seuil de pente maximum (ripage=1) :                          ")+str(max_exca_slope)+" %\n"
    txt += QCoreApplication.translate("MainWindow","   - Seuil de pente minimum (ripage=0) :                          ")+str(min_exca_slope)+" %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pas de l'analyse :                                           ")+str_stp
    txt += QCoreApplication.translate("MainWindow","   - Largeur de la zone tampon autour de l'axe théorique :        ")+str_xy
    txt += QCoreApplication.translate("MainWindow","   - Sauvegarde des profils perpendiculaires :                    ")+str_fig
    txt += QCoreApplication.translate("MainWindow","   - Sauvegarde des couches SIG :                                 ")+str_shp+'\n'
    if from_Sylvaroad:
        txt += QCoreApplication.translate("MainWindow","   - Retracer les lacets :                                        Non\n"  )
    else:
        txt += QCoreApplication.translate("MainWindow","   - Retracer les lacets :                                        Oui\n"  )
        txt += QCoreApplication.translate("MainWindow","     + Rayon de courbure appliqué aux lacets :                    ")+str(Radius)+ " m\n"
        txt += QCoreApplication.translate("MainWindow","     + Angle au-delà duquel un virage est considéré comme lacet : ")+str(angle_hairpin)+ " °\n"
        
    return txt


def repeat_space(max_length, var):
    txt = var + ' ' * (max_length - len(var))
    return txt


def create_param_file(Rspace,param,str_duree,str_fin,str_debut,ltot,vdeb,vevac,
                      vremb,semp,vroc,ltot0,vdeb0,vevac0,vremb0,semp0,vroc0):
    
    max_length = max(len(ltot0),len(vdeb0),len(vevac0),len(vremb0),len(semp0),len(vroc0))
    
    filename = Rspace +"Parametre_simulation.txt"    
    txt = "CubaRoad\n\n"
    ver = "0.2"
    date = "08/2021"
    txt += QCoreApplication.translate("MainWindow","Version du programme: ") + ver + " - " + date + "\n"
    txt += QCoreApplication.translate("MainWindow","Auteur: Sylvain DUPIRE - SylvaLab\n\n")
    txt += QCoreApplication.translate("MainWindow","Date et heure de lancement du script:                                      ")+str_debut+"\n"
    txt += QCoreApplication.translate("MainWindow","Date et heure a la fin de l'éxécution du script:                           ")+str_fin+"\n"
    txt += QCoreApplication.translate("MainWindow","Temps total d'éxécution du script:                                         ")+str_duree+"\n\n"
    txt += param

    txt += "\n\n"
    txt += QCoreApplication.translate("MainWindow","RESULTATS DU CALCUL:\n\n")
    txt +=QCoreApplication.translate("MainWindow","                                       Sans pas d'analyse     Avec pas d'analyse\n") 
    txt += QCoreApplication.translate("MainWindow","   - Longueur planimétrique du tracé : ") + ltot0 + ' m ' + repeat_space(max_length,ltot0)+ ltot + ' m\n'
    txt += QCoreApplication.translate("MainWindow","   - Volume en déblai :                ") + vdeb0 + ' m\u00B3'+ repeat_space(max_length,vdeb0)+ vdeb + ' m\u00B3\n'
    txt += QCoreApplication.translate("MainWindow","     * dont volume à évacuer :         ")+ vevac0 + ' m\u00B3'+ repeat_space(max_length,vevac0)+ vevac + ' m\u00B3\n'
    txt += QCoreApplication.translate("MainWindow","     * dont volume de roche :          ") + vroc0 + ' m\u00B3'+ repeat_space(max_length,vroc0)+ vroc+ ' m\u00B3\n'
    txt += QCoreApplication.translate("MainWindow","   - Volume en remblai :               ") + vremb0 + ' m\u00B3'+ repeat_space(max_length,vremb0)+ vremb+ ' m\u00B3\n'
    txt += QCoreApplication.translate("MainWindow","   - Surface d'emprise :               ") + semp0 + ' m²'+ repeat_space(max_length,semp0)+ semp + ' m²\n'
    
    
    fichier = open(filename, "w")
    fichier.write(txt)
    fichier.close()


def save_param_file(Wspace,Dtm_file,Road_file,Res_dir,step,max_exca_slope,
                    min_exca_slope,z_tolerance,xy_tolerance,save_fig,save_shp,
                    Rspace,from_Sylvaroad,Radius,angle_hairpin):
    param = []
    if step is None:
        sstep='None'
    else:
        sstep=step
    if xy_tolerance is None:
        sxy='None'
    else:
        sxy=xy_tolerance
    param.append([Wspace,Dtm_file,Road_file,Res_dir,sstep,max_exca_slope,
                  min_exca_slope,z_tolerance,sxy,save_fig,save_shp,
                  from_Sylvaroad,Radius,angle_hairpin])
    param = np.array(param)
    np.save(Rspace+"CubaRoad_param.npy",param)


def heures(Hdebut):
    Hfin = datetime.datetime.now()
    duree = Hfin - Hdebut
    str_duree = str(duree).split('.')[0]
    str_duree = str_duree.split(':')[0] + 'h ' + str_duree.split(':')[1] + 'm ' + str_duree.split(':')[2] + 's'
    str_debut = Hdebut.strftime('%d/%m/%Y %H:%M:%S')
    str_fin = Hfin.strftime('%d/%m/%Y %H:%M:%S')
    
    return str_duree, str_fin, str_debut


def create_res_dir(Result_Dir,Csize,step):
    try:os.mkdir(Result_Dir)
    except:pass  
    dirs = [d for d in os.listdir(Result_Dir) if os.path.isdir(os.path.join(Result_Dir, d))]
    list_dir = []
    for dire in dirs:
        if dire[:5]=='Simu_':
            list_dir.append(dire)
    optnum = len(list_dir)+1
    Rspace=Result_Dir+'Simu_'+str(optnum)    
    if int(Csize)==Csize:
        str_Csize = str(int(Csize))+"m"
    else:str_Csize = str(round(Csize,1))+"m"
        
    Rspace+="_Res("+str_Csize+")"
    Rspace+="_Pas("+str(step)+")"    
    try:os.mkdir(Rspace)
    except:pass   
    return Rspace+'/'


def build_center_line(Res_dir,source_srs,Pt_list):    
    val = np.unique(Pt_list[:,19])
    centers = np.zeros((val.shape[0],9),dtype=np.float32)
    #idpt xniv yniv zniv xcenter ycenter zcenter dzcenter nivinplat
    #0    1    2    3    4       5       6       7        8
    for i,pt in enumerate(val):
        centers[i,0]=pt
        inds = np.argwhere(Pt_list[:,19]==pt)[:,0]
        centers[i,1:4]=Pt_list[inds[0],4:7]
        if Pt_list[inds[0],15]==1:
            centers[i,8]=1
        elif Pt_list[inds[0],15]>0 and Pt_list[inds[0],18]==1:
            centers[i,8]=1
        if inds.shape[0]==1:            
            centers[i,4:8]=Pt_list[inds[0],7:11]
        else:
            for col in [4,5,6,7]:
                centers[i,col]=0.5*(Pt_list[inds[0],3+col]+Pt_list[inds[1],3+col])                
    
    driver = ogr.GetDriverByName('ESRI Shapefile')      
    ###############################################
    ### Save center line
    ###############################################  
    emp_name = Res_dir+"L_Centre_plateforme.shp"
    if os.path.exists(emp_name):driver.DeleteDataSource(emp_name)
    target_ds = driver.CreateDataSource(emp_name)
    layerName = os.path.splitext(os.path.split(emp_name)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()    
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LONGUEUR', ogr.OFTReal)
    layer.CreateField(new_field)    
    new_field = ogr.FieldDefn('PENTE_LONG', ogr.OFTReal)
    layer.CreateField(new_field)    
    ID=1
    for i in range(0,val.shape[0]-1):
        line = ogr.Geometry(ogr.wkbLineString)
        line.AddPoint(centers[i,4],centers[i,5])
        line.AddPoint(centers[i+1,4],centers[i+1,5])            
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ID) 
        feature.SetField('ID',ID) 
        feature.SetField('LONGUEUR',line.Length()) 
        pente = round((centers[i+1,6]-centers[i,6])/line.Length()*100,2)
        feature.SetField('PENTE_LONG',pente) 
        layer.CreateFeature(feature)   
        feature.Destroy()
        line.Destroy()
        ID+=1
    target_ds.Destroy()   
    ###############################################
    ### Save nivel line
    ###############################################  

    driver = ogr.GetDriverByName('ESRI Shapefile')      
    #Create output point shapefile
    emp_name = Res_dir+"L_niveau.shp"
    if os.path.exists(emp_name):driver.DeleteDataSource(emp_name)
    target_ds = driver.CreateDataSource(emp_name)
    layerName = os.path.splitext(os.path.split(emp_name)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()    
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LONGUEUR', ogr.OFTReal)
    layer.CreateField(new_field)    
    ID=1
    for i in range(0,val.shape[0]-1):
        if centers[i,8]==1 and centers[i+1,8]==1:
            line = ogr.Geometry(ogr.wkbLineString)
            line.AddPoint(centers[i,1],centers[i,2])
            line.AddPoint(centers[i+1,1],centers[i+1,2])            
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(line)
            feature.SetFID(ID) 
            feature.SetField('ID',ID) 
            feature.SetField('LONGUEUR',line.Length()) 
            layer.CreateFeature(feature)   
            feature.Destroy()
            line.Destroy()
            ID+=1
    target_ds.Destroy()      
    ###############################################
    ### Save center and nivel point
    ###############################################       
    Point_Shape_Path = Res_dir+"P_centre_et_niveau.shp"
    if os.path.exists(Point_Shape_Path):driver.DeleteDataSource(Point_Shape_Path)
    target_ds = driver.CreateDataSource(Point_Shape_Path)
    layerName = os.path.splitext(os.path.split(Point_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('ID_PT', ogr.OFTInteger)
    layer.CreateField(new_field)   
    new_field = ogr.FieldDefn('TYPE', ogr.OFTString)
    layer.CreateField(new_field)  
    new_field = ogr.FieldDefn('X', ogr.OFTReal)
    layer.CreateField(new_field)  
    new_field = ogr.FieldDefn('Y', ogr.OFTReal)
    layer.CreateField(new_field)  
    new_field = ogr.FieldDefn('Z', ogr.OFTReal)
    layer.CreateField(new_field)  
    new_field = ogr.FieldDefn('DZ', ogr.OFTReal)
    layer.CreateField(new_field)  
    pt_ind=1
    for pt in centers:
        geometry = ogr.Geometry(ogr.wkbPoint)
        geometry.AddPoint(pt[4], pt[5])
        # Create feature
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(pt_ind)
        feature.SetField('ID_PT',int(pt[0])) 
        feature.SetField('TYPE',"Centre") 
        feature.SetField('X',pt[4]) 
        feature.SetField('Y',pt[5]) 
        feature.SetField('Z',pt[6]) 
        feature.SetField('DZ',pt[7]) 
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        geometry.Destroy()
        feature.Destroy()
        pt_ind+=1 
        if pt[8]==1:
            # Create point
            geometry = ogr.Geometry(ogr.wkbPoint)
            geometry.AddPoint(pt[1], pt[2])
            # Create feature
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetFID(pt_ind)
            feature.SetField('ID_PT',int(pt[0])) 
            feature.SetField('TYPE',"Niveau") 
            feature.SetField('X',pt[1]) 
            feature.SetField('Y',pt[2]) 
            feature.SetField('Z',pt[3]) 
            feature.SetField('DZ',0) 
            # Save feature
            layer.CreateFeature(feature)
            # Cleanup
            geometry.Destroy()
            feature.Destroy()
            pt_ind+=1 
    target_ds.Destroy()     
            
        
def check_sign(a,b):
    if a*b==0:
        if a<0 or b<0:
            return False
        else:
            return True    
    elif abs(a*b)==a*b :
        return True
    else:
        return False


def build_assiette(Pt_list,Rspace,source_srs,pt_analyse):
    nbpt = Pt_list.shape[0]
    Pt_list2 = np.copy(Pt_list)
    #sans pt niveau en ligne droite
    inds = np.argwhere(((Pt_list2[:,15]==0)*(Pt_list2[:,18]==1))>0)[:,0]
    for i in inds:
        if not check_sign(Pt_list2[i-1,16],Pt_list2[i,16]):            
            Pt_list2[i,15] = 2
            Pt_list2[i,16] = 0
            Pt_list2[i,4:6]=Pt_list2[i,0:2]
        else:
            Pt_list2[i,15] = 3
            Pt_list2[i,17] = 0
            Pt_list2[i,4:6]=Pt_list2[i,13:15]
               
    #sans pt niveau en lacet
    inds = np.argwhere(((Pt_list2[:,15]==0)*(Pt_list2[:,18]==0))>0)[:,0]      
    for i in inds:        
        posilacet = pt_analyse[i,14]
        #on est dans l'entree 
        if posilacet<3:            
            if not check_sign(Pt_list2[i-1,16],Pt_list2[i,16]): 
                Pt_list2[i,15] = 2
                Pt_list2[i,16] = 0
                Pt_list2[i,4:6]=Pt_list2[i,0:2]
            else:
                Pt_list2[i,15] = 3
                Pt_list2[i,17] = 0
                Pt_list2[i,4:6]=Pt_list2[i,13:15]
        #on est dans le rayon du lacet
        elif pt_analyse[i+1,14]>posilacet and posilacet>2:
            if Pt_list2[i-1,15]>0 and Pt_list2[i-1,15]<10 and  Pt_list2[i-1,6]!=-2:
                #vrai point de niveau avant
                Pt_list2[i,4:6]=Pt_list2[i-1,4:6]  
                Pt_list2[i,15]=10      
            else:
                #pas de vrai point de niveau avant
                if Pt_list2[i-1,13]==Pt_list2[i,13] and Pt_list2[i-1,14]==Pt_list2[i,14]:
                    #on tourne droite donc centre = d1
                    Pt_list2[i,4:6]=Pt_list2[i,13:15]  
                    Pt_list2[i,15]=10   
                    Pt_list2[i,17]=0  
                else:
                    #on tourne gauche donc centre = g1
                    Pt_list2[i,4:6]=Pt_list2[i-1,0:2]  
                    Pt_list2[i,15]=10  
                    Pt_list2[i,16]=0  
        #on est dans la sortie        
        else: 
            if not check_sign(Pt_list2[i-1,16],Pt_list2[i,16]): 
                Pt_list2[i,15] = 2
                Pt_list2[i,16] = 0
                Pt_list2[i,4:6]=Pt_list2[i,0:2]
            else:
                Pt_list2[i,15] = 3
                Pt_list2[i,17] = 0
                Pt_list2[i,4:6]=Pt_list2[i,13:15]
    
    #Compute new xy when 2 pts are the same             
    val = np.unique(Pt_list2[:,19])
    Pt_list3 = np.copy(Pt_list2)
    Pt_list2 = np.zeros((val.shape[0],Pt_list3.shape[1]),dtype=np.float32)    
    for i,pt in enumerate(val): 
        inds = np.argwhere(Pt_list[:,19]==pt)[:,0]
        Pt_list2[i]=Pt_list3[inds[0]]
        if inds.shape[0]>1: 
            for col in [0,1,2,3,7,8,9,11,12,13,14]:
                 Pt_list2[i,col]=0.5*(Pt_list[inds[0],col]+Pt_list[inds[1],col])    
    
    nbpt = Pt_list2.shape[0]
    
    ###############################################
    ### Save total extent
    ###############################################     
    driver = ogr.GetDriverByName('ESRI Shapefile')      
    #Create output point shapefile
    emp_name = Rspace+"S_Emprise_totale.shp"
    if os.path.exists(emp_name):driver.DeleteDataSource(emp_name)
    target_ds = driver.CreateDataSource(emp_name)
    layerName = os.path.splitext(os.path.split(emp_name)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbPolygon)
    layerDefinition = layer.GetLayerDefn()    
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('TYPE', ogr.OFTString)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('SURFACE_M2', ogr.OFTReal)
    layer.CreateField(new_field)
    ID = 1
    for i in range(0,nbpt-1):
        #info pt i
        p1_xg1,p1_yg1,p1_xg2,p1_yg2,p1_xniv,p1_yniv = Pt_list2[i,0:6] 
        p1_xd2,p1_yd2,p1_xd1,p1_yd1,p1_nivinplat,p1_g,p1_d = Pt_list2[i,11:18]
        #info pt i+1
        p2_xg1,p2_yg1,p2_xg2,p2_yg2,p2_xniv,p2_yniv = Pt_list2[i+1,0:6] 
        p2_xd2,p2_yd2,p2_xd1,p2_yd1,p2_nivinplat,p2_g,p2_d = Pt_list2[i+1,11:18]    
        #Gauche        
        ring = ogr.Geometry(ogr.wkbLinearRing)  
        ring.AddPoint(p1_xniv,p1_yniv) 
        ring.AddPoint(p1_xg1,p1_yg1)  
        ring.AddPoint(p2_xg1,p2_yg1)  
        ring.AddPoint(p2_xniv,p2_yniv)
        ring.AddPoint(p1_xniv,p1_yniv)                 
        poly = ogr.Geometry(ogr.wkbPolygon)
        poly.AddGeometry(ring)
        if round(poly.Area(),2)>0:    
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(poly)
            feature.SetField('ID',ID)  
            if p1_g==0:
                if p2_g<0:
                    feature.SetField('TYPE',"Deblai")            
                else:
                    feature.SetField('TYPE',"Remblai")
            elif p1_g<0:
                feature.SetField('TYPE',"Deblai")            
            else:
                feature.SetField('TYPE',"Remblai")
            feature.SetField('SURFACE_M2',poly.Area())
            layer.CreateFeature(feature)            
            feature.Destroy()
            ID+=1
        poly.Destroy()
        #Droite      
        ring = ogr.Geometry(ogr.wkbLinearRing)    
        ring.AddPoint(p1_xniv,p1_yniv) 
        ring.AddPoint(p1_xd1,p1_yd1)  
        ring.AddPoint(p2_xd1,p2_yd1)  
        ring.AddPoint(p2_xniv,p2_yniv)
        ring.AddPoint(p1_xniv,p1_yniv)    
        poly = ogr.Geometry(ogr.wkbPolygon)
        poly.AddGeometry(ring)
        if round(poly.Area(),2)>0:    
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(poly)
            feature.SetField('ID',ID)
            if p1_d==0:
                if p2_d<0:
                    feature.SetField('TYPE',"Deblai")            
                else:
                    feature.SetField('TYPE',"Remblai")
            elif p1_d<0:
                feature.SetField('TYPE',"Deblai")            
            else:
                feature.SetField('TYPE',"Remblai")
            
            feature.SetField('SURFACE_M2',poly.Area())
            layer.CreateFeature(feature)        
            feature.Destroy()
            ID+=1     
        poly.Destroy()
    target_ds.Destroy()
    ###############################################
    ### Save road extent
    ###############################################        
    driver = ogr.GetDriverByName('ESRI Shapefile')      
    #Create output point shapefile
    emp_name = Rspace+"S_Assise_route.shp"
    if os.path.exists(emp_name):driver.DeleteDataSource(emp_name)
    target_ds = driver.CreateDataSource(emp_name)
    layerName = os.path.splitext(os.path.split(emp_name)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbPolygon)
    layerDefinition = layer.GetLayerDefn()    
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LARGEUR', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PLAN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_3D', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PENTE', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZ_GRAD', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('SURFACE_M2', ogr.OFTReal)
    layer.CreateField(new_field)
    ID = 1
    for i in range(0,nbpt-1):
        #info pt i
        p1_xg2,p1_yg2 = Pt_list2[i,2:4] 
        p1_xd2,p1_yd2 = Pt_list2[i,11:13]
        p1_xc,p1_yc,p1_zc = Pt_list2[i,7:10]
        #info pt i+1
        p2_xg2,p2_yg2 = Pt_list2[i+1,2:4] 
        p2_xd2,p2_yd2 = Pt_list2[i+1,11:13]
        p2_xc,p2_yc,p2_zc = Pt_list2[i+1,7:10]
        #
        D1 = Distplan(p1_yg2, p1_xg2,p1_yd2,p1_xd2)
        D2 = Distplan(p2_yg2, p2_xg2,p2_yd2,p2_xd2)
        Larg = round(0.5*(D1+D2),1)
        Az = int(calculate_azimut(p1_xc,p1_yc,p2_xc,p2_yc)*20/18+0.5)
        Lplan = Distplan(p1_yc, p1_xc,p2_yc,p2_xc)
        Dz = (p2_zc-p1_zc)
        Pente = round(100*Dz/Lplan,1)
        L3D = round(math.sqrt(Lplan**2+Dz**2),1)
        
        #Draw poly      
        ring = ogr.Geometry(ogr.wkbLinearRing)  
        ring.AddPoint(p1_xg2,p1_yg2) 
        ring.AddPoint(p1_xd2,p1_yd2)  
        ring.AddPoint(p2_xd2,p2_yd2)  
        ring.AddPoint(p2_xg2,p2_yg2)
        ring.AddPoint(p1_xg2,p1_yg2)                 
        poly = ogr.Geometry(ogr.wkbPolygon)
        poly.AddGeometry(ring)
        if round(poly.Area(),2)>0:    
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(poly)
            feature.SetField('ID',ID)  
            feature.SetField('LARGEUR',Larg)  
            feature.SetField('L_PLAN',round(Lplan,2)) 
            feature.SetField('L_3D',L3D) 
            feature.SetField('PENTE',Pente) 
            feature.SetField('AZ_GRAD',Az)           
            feature.SetField('SURFACE_M2',poly.Area())
            layer.CreateFeature(feature)            
            feature.Destroy()
            ID+=1
        poly.Destroy()        
    target_ds.Destroy()     


def get_id_lacets(Path,angle_hairpin):
    id_lacet_classique = []    
    for i,pt in enumerate(Path[1:-1]):
        az1 = pt[4]
        az2 = Path[i+2,4]
        difangle1 = diff_az(az1,az2)
        if difangle1 > angle_hairpin:
            id_lacet_classique.append(i+1)   
            
    id_lacet_bis = [] 
    dif_angle = []
    for i,pt in enumerate(Path[1:-1]):
        if i in id_lacet_classique:
            continue
        if i-1 in id_lacet_classique:
            continue
        if i+1 in id_lacet_classique:
            continue
        if i+2 in id_lacet_classique:
            continue        
       
        if i+3<Path.shape[0]:
            az1 = pt[4]
            az2 = Path[i+2,4]
            difangle1 = diff_az(az1,az2)
            if abs((az2-difangle1)%360-az1)<0.1:
                difangle1*=-1
            az3 = Path[i+3,4]
            difangle2 = diff_az(az2,az3)
            if abs((az3-difangle2)%360-az2)<0.1:
                difangle2*=-1          
            
            if i in id_lacet_bis:                
                idx = id_lacet_bis.index(i)
                if dif_angle[idx]> abs(difangle1+difangle2):
                    continue
                else:
                    del dif_angle[idx],id_lacet_bis[idx]
                
            if i-1 in id_lacet_bis:
                idx = id_lacet_bis.index(i-1)
                if dif_angle[idx]> abs(difangle1+difangle2):
                    continue
                else:
                    del dif_angle[idx],id_lacet_bis[idx]
                
            if abs(difangle1+difangle2) > angle_hairpin:
                dif_angle.append(abs(difangle1+difangle2))
                id_lacet_bis.append(i+1)
                      
    lacets = np.zeros((len(id_lacet_bis)+len(id_lacet_classique),2),dtype=np.int32)
    lacets[:len(id_lacet_bis),0]=id_lacet_bis
    lacets[:len(id_lacet_bis),1]=2
    lacets[len(id_lacet_bis):,0]=id_lacet_classique
    lacets[len(id_lacet_bis):,1]=1
    ind = np.lexsort([lacets[:,1],lacets[:,0]])
    return lacets[ind]


def build_radius(R):
    coords =np.zeros((360,3),dtype=np.float32) 
    for pol in range(0,360):
        coords[pol,0]=pol
        coords[pol,1]= R*math.cos(math.radians((pol)%360))#x
        coords[pol,2]= R*math.sin(math.radians((pol)%360))#y
    return coords


def calculate_polar(x1,y1,x2,y2):
    """
    Calculate the azimuth between two points from their coordinates
    """
    DX = x2-x1
    DY = y2-y1
    Deuc = math.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = math.degrees(math.acos(DY/Deuc))
    Angle *=Fact
    az = Angle%360
    return conv_az_to_polar(az)


def NewPath_to_lineshape(Path,Line_Shape_Path,projection):
    """
    Convert a file of point coordinate to a line shapefile
    ----------
    Parametres
    ----------
    point_coords:     ndarray float    Matrix contenaing positiosn X Y and line ID
    Line_Shape_Path:  string           Complete name of the output shapefile containing lines
    projection:       string           Spatial projection 

    Examples
    --------
    >>> import ogr,gdal
    >>> points_to_lineshape(point_coords,"Line.shp",projection)
    """   
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output line shapefile 
    if os.path.exists(Line_Shape_Path):driver.DeleteDataSource(Line_Shape_Path)
    target_ds = driver.CreateDataSource(Line_Shape_Path)
    layerName = os.path.splitext(os.path.split(Line_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, projection, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()   
    new_field = ogr.FieldDefn('ID_SEG', ogr.OFTInteger)
    layer.CreateField(new_field)   
    new_field = ogr.FieldDefn('PENTE_LONG', ogr.OFTReal)
    layer.CreateField(new_field)    
    new_field = ogr.FieldDefn('METHOD', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PLAT', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AMONT', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AVAL', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('P_ROCHER', ogr.OFTInteger)
    layer.CreateField(new_field)    
    nbpts = Path.shape[0]
    ind=0
    point_coords = Path[:,0:2]   
    idseg=1
    while ind<nbpts-1: 
        line = ogr.Geometry(ogr.wkbLineString)
        yrS,xrS = point_coords[ind]
        yrE,xrE = point_coords[ind+1]        
        line.AddPoint(float(xrS),float(yrS))
        line.AddPoint(float(xrE),float(yrE))
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('METHOD',Path[ind+1,10])
        feature.SetField('ID_SEG',idseg)        
        feature.SetField('PENTE_LONG',float(Path[ind+1,3]))
        feature.SetField('L_PLAT',float(Path[ind,6]))
        feature.SetField('PT_AMONT',int(Path[ind,7]))
        feature.SetField('PT_AVAL',int(Path[ind,8]))
        feature.SetField('P_ROCHER',int(Path[ind,5]))
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
        idseg+=1
        ind +=1        

    target_ds.Destroy()  


def Modify_Roadfile(Road_file,dtmtree,Tab_xyz,Rspace_shp,Csize,angle_hairpin=110,R=10,coefplat=2):
    from shapely import speedups
    speedups.disable()
    from shapely.geometry import LineString
    from shapely.geometry import Point

    ############################
    ### Convert file to path
    ############################
    
    # Get line info
    source_ds = ogr.Open(Road_file)
    source_layer = source_ds.GetLayer()
    source_srs = source_layer.GetSpatialRef()
    nb_pt = 1
    for feat in source_layer:
        geom = feat.GetGeometryRef()
        nb_pt+= geom.GetPointCount()-1  
    
    Path = np.zeros( (nb_pt,9),dtype=np.float32)
    #y x z Slope_from az_from P_ROCHER L_PLAT PT_AMONT PT_AVAL
    #0 1 2 3          4       5        6      7        8
    idline = 0
    for feat in source_layer:
        geom = feat.GetGeometryRef()
        points = geom.GetPointCount()  
        try: 
            pt_rock = feat.GetField("P_ROCHER")
            if pt_rock is None:
                pt_rock =0
        except:
            pt_rock = 0        
        l_plat = feat.GetField("L_PLAT")
        s_up = feat.GetField("PT_AMONT")
        s_down = feat.GetField("PT_AVAL") 
        idmin = 1
        if idline==0:
            idmin=0       
        
        for p in range(idmin,points):            
            x,y,z = geom.GetPoint(p)        
            z=get_z([x,y],dtmtree,Tab_xyz)
            
            if idline>0:
                dz = z-Path[idline-1,2]
                Dist = Distplan(Path[idline-1,0],Path[idline-1,1],y,x)
                Slope = dz/Dist*100
                az = calculate_azimut(Path[idline-1,1],Path[idline-1,0],x,y)
            else:
                Slope = -1
                az = -1
            Path[idline]=y,x,z,Slope,az,pt_rock,l_plat,s_up,s_down
            idline+=1
    
    ############################
    ### identify lace turns
    ############################        
    lacets = get_id_lacets(Path,angle_hairpin)        
  
    ############################
    ### retrace line
    ############################        
    coords = build_radius(R)    
    newPath = np.zeros((Path.shape[0],Path.shape[1]+2))
    #y x z Slope_from az_from P_ROCHER L_PLAT PT_AMONT PT_AVAL IDLAC LACTYPE
    #0 1 2 3          4       5        6      7        8       9     10
    newPath[:,0:9] = Path[:,0:9]
    Path=np.copy(newPath)    
    for lac in lacets:
        Path[lac[0],9]=lac[0]
        Path[lac[0],10]=lac[1]
            
    for lac in lacets: 
        line_lac,method = lac 
        try:
            line_lac=np.argwhere(Path[:,9]==line_lac)[0,0]             
        except:
            continue

        if method==1:
            #Angle > hairpin between 2 segments / Center at turn
            B = Point(Path[line_lac,1], Path[line_lac,0])
        else:
            #Angle > hairpin between 3 segments 
            #Center on the middle point of the segment
            A = Point(Path[line_lac,1], Path[line_lac,0])
            D = Point(Path[line_lac+1,1], Path[line_lac+1,0])           
            B = Point(0.5*A.x+0.5*D.x,0.5*A.y+0.5*D.y)            
         
        RingR15 = B.buffer(R*coefplat).boundary
        #find intersection before
        #A = Point(Path[line_lac-1,1], Path[line_lac-1,0])  
        cutpt_bef = 0
        check_int=False
        while not check_int and cutpt_bef*Csize<R*(coefplat+0.5):   
            cutpt_bef+=1
            vois = []
            for ide in range(max(0,line_lac-cutpt_bef),line_lac+1):
                vois.append(Point(Path[ide,1], Path[ide,0]))
            RoadBef = LineString(vois)
            check_int = RingR15.intersects(RoadBef)
            
        if check_int:
            intbef = RingR15.intersection(RoadBef)
            x1 = Point(intbef.coords[0]) 
            x,y = Path[line_lac-cutpt_bef+1,1],Path[line_lac-cutpt_bef+1,0]
            D = Distplan(y, x, x1.y, x1.x)
            x1z = Path[line_lac-cutpt_bef+1,2]-Path[line_lac-cutpt_bef+1,3]/100*D
        else:                
            continue
                
        #find intersection after
        #C = Point(Path[line_lac+1,1], Path[line_lac+1,0])
        cutpt_aft = 0
        check_int=False
        while not check_int and cutpt_aft*Csize<R*(coefplat+0.5):   
            cutpt_aft+=1
            vois = []
            for ide in range(line_lac,min(Path.shape[0],line_lac+cutpt_aft+1)):
                vois.append(Point(Path[ide,1], Path[ide,0]))
            RoadAft = LineString(vois)
            check_int = RingR15.intersects(RoadAft)
            
        if check_int:
            intaft = RingR15.intersection(RoadAft)
            x2 = Point(intaft.coords[0])
            x,y = Path[line_lac+cutpt_aft,1],Path[line_lac+cutpt_aft,0]
            D = Distplan(y, x, x2.y, x2.x)
            x2z = Path[line_lac+cutpt_aft,2]-Path[line_lac+cutpt_aft,3]/100*D
        else:                
            continue
        
        #get turn direction
        azfrom = Path[line_lac,4]
        azto = Path[line_lac+1,4]
        dif = diff_az(azfrom,azto)
        sign=1
        if abs((azto-dif)%360-azfrom)<0.1:
            sign*=-1
               
        #get point on radius                
        pol1 = calculate_polar(B.x,B.y,x1.x,x1.y)
        pol2 = calculate_polar(B.x,B.y,x2.x,x2.y)        
                  
        diff_angle = 360-diff_az(pol2,pol1)  
               
        nbpt = int(diff_angle/45.) 
        start = int(0.5*(360-(nbpt-1)*45-diff_az(pol2,pol1))+0.5)  
        pt_list = []
        pol = int((pol1+sign*start)%360+0.5)        
        xbef,ybef=x1.x,x1.y
        x,y=coords[pol,1]+B.x,coords[pol,2]+B.y
        D = []
        D.append(Distplan(y, x, ybef,xbef))       
        pt_list.append([x,y])
        ybef,xbef=y,x
        for i in range(1,nbpt):            
            pol = int((pol1+i*sign*45+sign*start)%360)
            x,y=coords[pol,1]+B.x,coords[pol,2]+B.y
            pt_list.append([x,y])
            D.append(Distplan(y, x, ybef,xbef))
            xbef,ybef=x,y
        D.append(Distplan(x2.y, x2.x, ybef,xbef))
        Dcum=np.sum(D)  
        sl = (x2z-x1z) /  Dcum   
        prock = Path[line_lac,5]
        lpla = Path[line_lac,6]
        sup = Path[line_lac,7]
        sdown = Path[line_lac,8]        
        
        newPath = np.zeros((Path.shape[0]+len(pt_list)+3-cutpt_bef-cutpt_aft,Path.shape[1]))
        newPath[0:line_lac-cutpt_bef+1]= Path[0:line_lac-cutpt_bef+1]
        newPath[line_lac-cutpt_bef+1,0:2] = x1.y,x1.x            
        newPath[line_lac-cutpt_bef+1,9:11] = lac[0],0
        newPath[line_lac-cutpt_bef+1,5:9] = prock,lpla,sup,sdown
        newPath[line_lac-cutpt_bef+1,2] = x1z 
        newPath[line_lac-cutpt_bef+1,3] = Path[line_lac-cutpt_bef+1,3]
        for i,pt in enumerate(pt_list):
            newPath[line_lac-cutpt_bef+2+i,0:2]=pt[1],pt[0]
            newPath[line_lac-cutpt_bef+2+i,9:11] = lac[0],1
            newPath[line_lac-cutpt_bef+2+i,3] = sl*100
            newPath[line_lac-cutpt_bef+2+i,2] = x1z+sl*np.sum(D[:i+1])
            newPath[line_lac-cutpt_bef+2+i,5:9] = prock,lpla,sup,sdown
        newPath[line_lac-cutpt_bef+3+i,0:2]=x2.y,x2.x
        newPath[line_lac-cutpt_bef+3+i,2]=x2z
        newPath[line_lac-cutpt_bef+3+i,3]=sl*100
        newPath[line_lac-cutpt_bef+3+i,9:11] = lac[0],1
        newPath[line_lac-cutpt_bef+3+i,5:9] = prock,lpla,sup,sdown
        newPath[line_lac-cutpt_bef+4+i:]=Path[line_lac+cutpt_aft:] 
    
        Path=np.copy(newPath)

    NewPath_to_lineshape(Path,Rspace_shp+"Trace_avec_lacets_corriges.shp",source_srs)
    return Rspace_shp+"Trace_avec_lacets_corriges.shp"


################################################################################
### Script execution
################################################################################

def apply_cubaroad(Dtm_file,Road_file,Res_dir,step,max_exca_slope,
                   min_exca_slope,z_tolerance,xy_tolerance,save_fig,
                   save_shp,Wspace,from_Sylvaroad,Radius,angle_hairpin):    
    #test
    console_info(f"DTM file: {Dtm_file}")
    console_info(f"Road file: {Road_file}")
    console_info(f"Result directory: {Res_dir}")
    console_info(f"Step: {step}")
    console_info(f"Max excavation slope: {max_exca_slope}")
    console_info(f"Min excavation slope: {min_exca_slope}")
    console_info(f"Z tolerance: {z_tolerance}")
    console_info(f"XY tolerance: {xy_tolerance}")
    console_info(f"Save figure: {save_fig}")
    console_info(f"Save shapefile: {save_shp}")
    console_info(f"Working directory: {Wspace}")
    console_info(f"From Sylvaroad: {from_Sylvaroad}")
    console_info(f"Radius: {Radius}")
    console_info(f"Angle hairpin: {angle_hairpin}")

    Hdebut = datetime.datetime.now()
    ver = 0.2
    console_info(QCoreApplication.translate("MainWindow","\nCubaRoad") + " - " + str(ver))
    console_info(QCoreApplication.translate("MainWindow","\n    - Vérification des donnees spatiales"))   
    test,mess,Csize=check_files(Dtm_file,Road_file,from_Sylvaroad)
    show_fig=False
    if not fig:
        save_fig=False
    
    #Save parameters into npy file
    param = get_param(Dtm_file ,Road_file,step,max_exca_slope,min_exca_slope,
                      xy_tolerance,Csize,save_shp,save_fig,from_Sylvaroad,Radius,angle_hairpin)
    
    Rspace=create_res_dir(Res_dir,Csize,step)
    
    save_param_file(Wspace,Dtm_file,Road_file,Res_dir,step,max_exca_slope,
                    min_exca_slope,z_tolerance,xy_tolerance,
                    save_fig,save_shp,Rspace,from_Sylvaroad,Radius,angle_hairpin)
    
    if not test:
        console_info(mess)
        
    else:        
        console_info(QCoreApplication.translate("MainWindow","    - Chargement des donnees"))      
        dtm,_,Csize,_,_,values,_ = load_float_raster(Dtm_file)
        Tab_xyz,dtmtree = build_xyz_tab(dtm,values)     
        
        if step!= None :
            step*=1.
        max_exca_slope /=100.
        min_exca_slope /=100.
        z_tolerance /=100.
        
        #Create shp directory if necessary
        Rspace_shp = Rspace
        if not from_Sylvaroad or save_shp:
            if os.path.exists(Rspace+"Shp_Model"):
                shutil.rmtree(Rspace+"Shp_Model")         
            try:os.mkdir(Rspace+"Shp_Model")
            except: pass        
            Rspace_shp += "Shp_Model/"
            
        #Trace lace in roadfile if necessary
        Road_file_used = Road_file
        if not from_Sylvaroad:
            Road_file_used = Modify_Roadfile(Road_file,dtmtree,Tab_xyz,
                                             Rspace_shp,Csize,angle_hairpin,Radius)
        
        #Extract point from segments
        seg_list,source_srs = linestring_to_seg(Road_file_used,Tab_xyz,dtmtree)            
        pt_analyse,centers_lac=get_pt_analyse(seg_list,step)
        
        
        if save_shp:            
            save_pt_analyse(pt_analyse,centers_lac,Rspace_shp,source_srs)       
        
        Trans_list = build_trans(pt_analyse,centers_lac,Csize,Rspace_shp,save_shp,source_srs)
        nbpt = Trans_list.shape[0]
        
        
        console_info(QCoreApplication.translate("MainWindow","    - Calcul des cubatures"))   
        
        
        Tab = np.zeros((nbpt,23))
        #ID_PT ID_SEG L_APP PT_LONG PT_G PT_D L_ASSIS ASSIS_DEB SEC_DEB V_DEB
        #0     1      2     3       4    5    6       7         8       9
        #ASSIS_REMB S_REMB V_REMB ASSIET_DEB ASSIET_REMB EMPRISE PT_TYPE CONFIG
        #10         11     12     13         14          15      16      17
        #TAL_AMONT TAL_AVAL MODIF_AMONT PIQ_CONTROL_AMONT PIQ_CONTROL_AVAL
        #18        19       20          21                22
        
        Pt_list = np.zeros((nbpt,20))
        #xg1 yg1 xg2 yg2 xniv yniv zniv xcenter ycenter zcenter dzcenter xd2 yd2 xd1 yd1 nivinplat Gauche Droite LigneDroite idpt
        #0   1   2   3   4    5    6    7       8       9       10       11  12  13  14  15        16     17     18          19
        
        if os.path.exists(Rspace+"Profils"):
            shutil.rmtree(Rspace+"Profils")
        if save_fig:  
            try:os.mkdir(Rspace+"Profils")
            except: pass
         
        for i,tr in enumerate(Trans_list):
            if tr[16]<2:
                Tab[i],Pt_list=get_profil(tr,i,Pt_list,Tab_xyz,dtmtree,min_exca_slope,max_exca_slope,
                                          xy_tolerance,z_tolerance,save_fig,Rspace,show_fig)      
                # try:
                #     Tab[i],Pt_list=get_profil(dtm,tr,i,Pt_list,Tab_xyz,dtmtree,min_exca_slope,max_exca_slope,
                #                                  xy_tolerance,z_tolerance,save_fig,Rspace,show_fig)           
                # except:
                #     console_info("       + Le calcul n'a pas été réalisé pour le point n°"+str(int(tr[15])))
                #     pass
            else:    
                if tr[16]==2:
                    try:
                        Tab[i],Pt_list=get_profil_L(tr,i,Pt_list,Tab_xyz,dtmtree,
                                                    0,z_tolerance,save_fig,Rspace,show_fig)           
                    except:
                        console_info(QCoreApplication.translate("MainWindow","       + Le calcul n'a pas été réalisé pour le point n°")+str(int(tr[15])))
                        pass
                else:
                    try:
                        Tab[i],Pt_list=get_profil_L2(tr,i,Pt_list,Tab_xyz,dtmtree,
                                                    0,z_tolerance,save_fig,Rspace,show_fig)           
                    except:
                        console_info(QCoreApplication.translate("MainWindow","       + Le calcul n'a pas été réalisé pour le point n°")+str(int(tr[15])))
                        pass
                    
        console_info(QCoreApplication.translate("MainWindow","    - Calcul terminé"))      
         
        ltot0,vdeb0,vevac0,vremb0,semp0,vroc0,Tab2 = save_Tab_init(Tab,Rspace,Pt_list,pt_analyse,max_exca_slope*100)
        save_Tab_Lace(Tab2,Rspace)
        
        if step!= None:    
            ltot,vdeb,vevac,vremb,semp,vroc = save_Tab(Tab,Rspace,Pt_list,pt_analyse,max_exca_slope*100)
        
        console_info(QCoreApplication.translate("MainWindow","    - Sauvergarde des tableaux terminée")) 
        
        Rspace_shp = Rspace
        if os.path.exists(Rspace+"Shp_Res"):
            shutil.rmtree(Rspace+"Shp_Res")    
        try:os.mkdir(Rspace+"Shp_Res")
        except: pass
        Rspace_shp += "Shp_Res/"
        
        build_center_line(Rspace_shp,source_srs,Pt_list)
        build_assiette(Pt_list,Rspace_shp,source_srs,pt_analyse)
        
        console_info(QCoreApplication.translate("MainWindow","    - Sauvergarde des couches SIG terminée")) 
        
        str_duree,str_fin,str_debut=heures(Hdebut)        
        create_param_file(Rspace,param,str_duree,str_fin,str_debut,ltot,
                          vdeb,vevac,vremb,semp,vroc,ltot0,vdeb0,vevac0,vremb0,semp0,vroc0)     
        
        console_info(QCoreApplication.translate("MainWindow","    - Traitement terminé"))
    
